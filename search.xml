<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基于Frp内网穿透反向代理的端口转发实现本地服务器]]></title>
    <url>%2F2019%2F01%2F07%2F%E5%9F%BA%E4%BA%8EFrp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[基于frp内网穿透反向代理的端口转发实现本地服务器frp简介frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp, http, https 协议。 利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务。 对于 http, https 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个80端口。 利用处于内网或防火墙后的机器，对外网环境提供 tcp 和 udp 服务，例如在家里通过 ssh 访问处于公司内网环境内的主机。 使用准备条件公网服务器一台，内网服务器一台，公网服务器绑定域名1个。 开始搭建公网服务器ssh连接到公网服务器上，新建目录 1mkdir -p /usr/local/frp 根据对应的操作系统及架构，从 Release 页面下载最新版本的程序。 1wget https://github.com/fatedier/frp/releases/download/v0.22.0/frp_0.22.0_linux_arm64.tar.gz 解压 1tar -zxvf frp_0.22.0_linux_arm64.tar.gz 首先删掉frpc、frpc.ini两个文件，然后再进行配置修改frps.ini文件，这里使用了最简化的配置： 1234567891011# frps.ini[common]bind_port = 7000vhost_http_port = 6081max_pool_count = 20allow_ports = 2000-3000,6081,4000-50000 #端口白名单dashboard_port = 7500dashboard_user = admindashboard_pwd = admintoken = 123456 #客户端也要配置一样的tokenauthentication_timeout = 90000 #超时时间，如果客户端遇到服务启动认证失败，大概率是时区问题，服务器设置一下就好了 保存然后启动服务1./frps -c ./frps.ini 这是前台启动，后台启动命令为 1nohup ./frps -c ./frps.ini &amp; 可以通过访问http://xx.xx.xx.xx:7500/static/#/proxies/tcp访问frp服务的监控界面，账号密码与上面配置的一致。 内网服务器根据对应的操作系统及架构，从 Release 页面下载最新版本的程序。 1wget https://github.com/fatedier/frp/releases/download/v0.22.0/frp_0.22.0_linux_arm64.tar.gz 解压 1tar -zxvf frp_0.22.0_linux_arm64.tar.gz 首先删掉frpc、frpc.ini两个文件，然后再进行配置修改 frpc.ini 文件。 123456789101112131415161718# frpc.ini[common]server_addr = xx.xx.xx.xx #公网ip地址server_port = 7000token = 123456 #公网通过ssh访问内部服务器[ssh]type = tcp #连接协议local_ip = 127.0.0.1local_port = 22 #ssh默认端口号remote_port = 6000 #自定义的访问内部ssh端口号 #公网访问内部web服务器以http方式[web]type = http #访问协议local_port = 8081 #内网web服务的端口号custom_domains = strongcat.top #所绑定的公网服务器域名，一级、二级域名都可以 保存然后执行启动 1./frpc -c ./frpc.ini 这是前台启动，后台启动命令为 1nohup ./frpc -c ./frpc.ini &amp; 使用我用的是centOS7的操作系统，为了防止因为网络或者重启问题Frp失效，所以写了一个开机启动服务，公网服务器配置： 12345678910111213[Unit]Description=frp[Service]TimeoutStartSec=30Type=simpleExecStart=/root/frp/frp_0.22.0_linux_386/frps -c /root/frp/frp_0.22.0_linux_386/frps.iniExecStop=/bin/kill $MAINPIDRestart=on-failureRestartSec=60s[Install]WantedBy=multi-user.target 内网服务器配置：123456789101112131415[Unit]Description=frpAfter=network.targetWants=network.target[Service]TimeoutStartSec=30Type=simpleExecStart=/root/frp/frp_0.22.0_linux_386/frpc -c /root/frp/frp_0.22.0_linux_386/frpc.iniExecStop=/bin/kill $MAINPIDRestart=on-failureRestartSec=60s[Install]WantedBy=multi-user.target 文件保存到/etc/systemd/system/frp.service中，并执行systemctl daemon-reload，systemctl start frp,开机启动systemctl enable frp 外网ssh访问内网服务器（直接使用配置里面数据演示） 1ssh -oPort=6000 root@x.x.x.x 将 www.strongcat.top 的域名 A 记录解析到 IP x.x.x.x，如果服务器已经有对应的域名，也可以将 CNAME 记录解析到服务器原先的域名。 通过浏览器访问 http://www.yourdomain.com:8080 即可访问到处于内网机器上的 web 服务。 有些系统默认自带防火墙，需要开通端口 123firewall-cmd --zone=public --add-port=6000/tcp --permanent systemctl stop firewalld.service systemctl start firewalld.service 如果遇到authorization timeout错误的话，需要进行2个服务器之间的时间同步。2边服务器都执行下面的命令：1234567891011#下载ntpdateyum install -y ntpdate#调整时区为上海，也就是北京时间+8区cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtimeyes | cp -f /usr/share/zoneinfo/Asia/Shanghai /etc/localtime#使用NTP来同步时间ntpdate us.pool.ntp.org#定时同步时间（每隔10分钟同步时钟）crontab -l &gt;/tmp/crontab.bakecho "*/10 * * * * /usr/sbin/ntpdate us.pool.ntp.org | logger -t NTP" &gt;&gt; /tmp/crontab.bakcrontab /tmp/crontab.bak 如果是像我这种笔记本的话，可以设置系统关闭盖子的动作1vim /etc/systemd/logind.conf 12345678910111213HandlePowerKey 按下电源键后的行为，默认power offHandleSleepKey 按下挂起键后的行为，默认suspendHandleHibernateKey 按下休眠键后的行为，默认hibernateHandleLidSwitch 合上笔记本盖后的行为，默认suspendignore 忽略，跳过power off 关机eboot 重启halt 挂起suspend shell内建指令，可暂停目前正在执行的shell。若要恢复，则必须使用SIGCONT信息。所有的进程都会暂停，但不是消失（halt是进程关闭）hibernate 让笔记本进入休眠状态hybrid-sleep 混合睡眠，主要是为台式机设计的，是睡眠和休眠的结合体，当你选择Hybird时，系统会像休眠一样把内存里的数据从头到尾复制到硬盘里 ，然后进入睡眠状态，即内存和CPU还是活动的，其他设置不活动，这样你想用电脑时就可以快速恢复到之前的状态了，笔记本一般不用这个功能。lock 仅锁屏，计算机继续工作。 更多指令可以参考这篇博客 最后重新加载服务使配置生效1systemctl restart systemd-logind]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Selenium测试框架]]></title>
    <url>%2F2019%2F01%2F04%2FSelenium%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[Selenium官网 Selenium简介Selenium可以对浏览器进行自动化测试。它主要用于自动化Web应用程序以进行测试，但当然不仅限于此。无聊的基于Web的管理任务也可以自动化。 Selenium得到了一些最大的浏览器供应商的支持，这些供应商已采取（或正在采取）将Selenium作为其浏览器本机部分的步骤。它也是无数其他浏览器自动化工具，API和框架的核心技术。支持多种语言，在java中可以作为自动化测试框架，在python中可以模拟页面用户点击对自动化爬虫进行补充。 支持的浏览器： Selenium使用Selenium提供了一种非常简单的开发方式，例如用Chrome开发的话，去开发者工具下载Katalon Selenium IDE，如图所示。 开始录制录制过程中，IDE会自动帮我们把命令行插入到测试用例中，包括： 单击链接 输入值 从下拉框选择数据 单击按钮或者选择框点击开始录制，在最上方输入网站域名，后期可以通过更换域名来实现不同域名下的应用的测试。 使用上下文菜单添加验证和断言使用Selenium IDE录制，转到显示测试应用程序的浏览器，然后右键单击页面上的任意位置。您将看到一个显示验证和/或断言命令的上下文菜单。Selenium命令有三种“风格”：动作，访问器和断言。 动作是通常操纵应用程序状态的命令。他们执行“点击此链接”和“选择该选项”之类的操作。如果操作失败或出错，则停止执行当前测试。 访问者检查应用程序的状态并将结果存储在变量中，例如“storeTitle”。它们还用于自动生成断言。 断言与访问器类似，但它们验证应用程序的状态是否符合预期。示例包括“确保页面标题为X”和“验证是否选中此复选框”。 脚本语法命令很简单，由2个参数构成： verifyText //div//a[2] Login 这些参数并不总是必需的;这取决于命令。在某些情况下，两者都是必需的，在其他情况下需要一个参数，而在另一些情况下，命令可能根本不需要参数。这里有几个例子： chooseCancelOnNextPrompt pause 500 type id=phone (555) 666-7066 type id=address1 ${myVariableAddress} 命令参考描述了每个命令的参数要求。 参数有所不同，但它们通常是： Locators用于标识页面内UI元素的定位器。 text patterns用于验证或声明预期页面内容的文本模式。 text patterns or selenium variables文本模式或selenium变量，用于在输入字段中输入文本或从选项列表中选择选项。常用的Selenium命令 open 打开url页面 click 执行单击操作，并可选择等待加载新页面。 verifyTitle/assertTitle 验证预期的页面标题。 verifyTextPresent 验证预期文本是否在页面上的某个位置。 verifyText 验证预期文本及其相应的HTML标记出现在页面上。 verifyTable 验证表的预期内容。 验证页面元素断言与验证的选择 assert 错误后会不继续执行并中断当前的测试用例 verify 错误后会继续执行的最佳用途是对测试命令进行逻辑分组，并使用“assert”后跟一个或多个“verify”测试命令启动每个组。一个例子如下： verifyElementPresent Command Target Value verifyElementPresent //div/p/img 此命令验证页面上是否存在由&lt;img&gt; HTML标记的存在指定的图像，并且它遵循&lt;div&gt;标记和&lt;p&gt;标记。第一个（也是唯一的）参数是一个定位器，用于告诉Selenese命令如何查找元素。verifyElementPresent可用于检查页面中是否存在任何HTML标记。您可以检查链接，段落，分区&lt;div&gt;等是否存在。以下是一些示例。 Command Target Value verifyElementPresent //div/p verifyElementPresent //div/a verifyElementPresent id=Login verifyElementPresent link=Go to Marketing Research verifyElementPresent //a[2] verifyElementPresent //head/title verifyText必须在测试文本及其UI元素时使用verifyText。 verifyText必须使用定位器。如果选择XPath或DOM定位器，则可以验证特定文本是否显示在页面上相对于页面上其他UI组件的特定位置。Command | Target | Value—|— |—verifyText |//table/tr/td/div/p | This is my text and it occurs right after the div inside the table. 定位元素对于许多Selenium命令，需要一个目标。此目标标识Web应用程序内容中的元素，并包含位置策略，后跟位置格式为locatorType = location。在许多情况下可以省略定位器类型。下面解释各种定位器类型，每个定位器类型都有示例。 按标识符定位例如，页面源可以具有id和name属性，如下所示：12345678910&lt;html&gt; &lt;body&gt; &lt;form id="loginForm"&gt; &lt;input name="username" type="text" /&gt; &lt;input name="password" type="password" /&gt; &lt;input name="continue" type="submit" value="Login" /&gt; &lt;input name="continue" type="button" value="Clear" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;html&gt; 以下定位器策略将返回上面由行号指示的HTML片段中的元素： identifier=loginForm (3) identifier=password (5) identifier=continue (6) continue (6)由于定位器的标识符类型是默认值，因此上面的前三个示例中的标识符=不是必需的。 通过id定位 id=loginForm (3) 通过名称定位 name=username (4) name=continue value=Clear (7) name=continue Clear (7) name=continue type=button (7) 与某些类型的XPath和DOM定位器不同，上面三种类型的定位器允许Selenium测试UI元素，而与其在页面上的位置无关。因此，如果页面结构和组织被更改，测试仍将通过。您可能想也可能不想测试页面结构是否发生变化。在Web设计者经常更改页面但其功能必须经过回归测试的情况下，通过id和name属性进行测试，或者通过任何HTML属性进行测试变得非常重要。 由于只有xpath定位符以“//”开头，因此在指定XPath定位符时不必包含xpath =标签。 xpath=/html/body/form[1] (3) - 绝对路径（如果HTML仅稍微更改，则会中断） //form[1] (3) - HTML中的第一个表单元素 xpath=//form[@id=’loginForm’] (3) - 表单元素，其属性名为“id”，值为“loginForm” xpath=//form[input/@name=’username’] (3) - 带有输入子元素的第一个表单元素，其属性名为“name”，值为“username” //input[@name=’username’] (4) - 第一个输入元素，其属性名为“name”，值为“username” //form[@id=’loginForm’]/input[1] (4) - 表单元素的第一个输入子元素，其属性名为“id”，值为“loginForm” //input[@name=’continue’][@type=’button’] (7) -输入名为’name’的属性和值’continue’以及名为’type’的属性和值’button’ //form[@id=’loginForm’]/input[4] (7) - 表单元素的第四个输入子元素，其属性名为“id”，值为“loginForm” 主要的语法参考Xpath可以使用浏览器的devtools复制XPath： 通过链接文本查找超链接 这是一种使用链接文本在网页中查找超链接的简单方法。如果存在具有相同文本的两个链接，则将使用第一个匹配。1234567&lt;html&gt; &lt;body&gt; &lt;p&gt;Are you sure you want to do this?&lt;/p&gt; &lt;a href="continue.html"&gt;Continue&lt;/a&gt; &lt;a href="cancel.html"&gt;Cancel&lt;/a&gt;&lt;/body&gt;&lt;html&gt; link=Continue (4) link=Cancel (5) 通过CSS定位 12345678910&lt;html&gt; &lt;body&gt; &lt;form id="loginForm"&gt; &lt;input class="required" name="username" type="text" /&gt; &lt;input class="required passfield" name="password" type="password" /&gt; &lt;input name="continue" type="submit" value="Login" /&gt; &lt;input name="continue" type="button" value="Clear" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;html&gt; css=form#loginForm (3) css=input[name=”username”] (4) css=input.required[type=”text”] (4) css=input.passfield (5) css=#loginForm input[type=”button”] (7) css=#loginForm input:nth-child(2) (5) 可以参考 the W3C publication 没有明确的设定选择器的话，将会默认使用id选择器 存储命令和Selenium变量可以使用Selenium变量在脚本开头存储常量。此外，当与数据驱动的测试设计（在后面的部分中讨论）结合使用时，Selenium变量可用于存储从命令行，从另一个程序或从文件传递到测试程序的值。 plain store命令是许多存储命令中最基本的命令，可用于在selenium变量中简单地存储常量值。它需要两个参数，即要存储的文本值和一个selenium变量。在为变量选择名称时，请使用仅包含字母数字字符的标准变量命名约定。 Command Target Value store paul@mysite.org userName 稍后在脚本中，将需要使用变量的存储值。要访问变量的值，请将变量括在大括号（{}）中，并在其前面加上美元符号。 Command Target Value verifyText //div/p ${userName} 变量的常见用途是存储输入字段的输入 Command Target Value type id=login ${userName} storeText StoreText对应于verifyText。它使用定位器来标识特定的页面文本。如果找到该文本，则存储在变量中。 StoreText可用于从正在测试的页面中提取文本。 echo命令可以用来打印变量 Alerts, Popups, and Multiple Windows123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;script type="text/javascript"&gt; function output(resultText)&#123; document.getElementById('output').childNodes[0].nodeValue=resultText; &#125; function show_confirm()&#123; var confirmation=confirm("Chose an option."); if (confirmation==true)&#123; output("Confirmed."); &#125; else&#123; output("Rejected!"); &#125; &#125; function show_alert()&#123; alert("I'm blocking!"); output("Alert is gone."); &#125; function show_prompt()&#123; var response = prompt("What's the best web QA tool?","Selenium"); output(response); &#125; function open_window(windowName)&#123; window.open("newWindow.html",windowName); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" id="btnConfirm" onclick="show_confirm()" value="Show confirm box" /&gt; &lt;input type="button" id="btnAlert" onclick="show_alert()" value="Show alert" /&gt; &lt;input type="button" id="btnPrompt" onclick="show_prompt()" value="Show prompt" /&gt; &lt;a href="newWindow.html" id="lnkNewWindow" target="_blank"&gt;New Window Link&lt;/a&gt; &lt;input type="button" id="btnNewNamelessWindow" onclick="open_window()" value="Open Nameless Window" /&gt; &lt;input type="button" id="btnNewNamedWindow" onclick="open_window('Mike')" value="Open Named Window" /&gt; &lt;br /&gt; &lt;span id="output"&gt; &lt;/span&gt;&lt;/body&gt;&lt;/html&gt; Command Description assertFoo(pattern) 如果模式与弹出窗口的文本不匹配，则抛出错误 assertFooPresent 如果弹出窗口不可用则抛出错误 assertFooNotPresent 如果存在任何弹出窗口则抛出错误 storeFoo(variable) 将弹出文本存储在变量中 storeFooPresent(variable) 将弹出窗口的文本存储在变量中并返回true或false 在Selenium下运行时，不会显示JavaScript弹出窗口。这是因为函数调用实际上是由Selenium自己的JavaScript在运行时覆盖的。但是，仅仅因为你看不到弹出窗口并不意味着你不必处理它。要处理弹出窗口，必须调用其assertFoo（模式）函数。如果您未能断言是否存在弹出窗口，则您的下一个命令将被阻止，您将收到类似于以下错误的错误[错误]错误error] Error: There was an unexpected Confirmation! [Chose an option.] Alerts让我们从Alerts开始，因为它们是最简单的弹出窗口。首先，在浏览器中打开上面的HTML示例，然后单击“Show alert”按钮。您会注意到，在您关闭警报后，页面上会显示“警报已消失。”文本。现在使用Selenium IDE录制完成相同的步骤，并在关闭警报后验证是否添加了文本。您的测试看起来像这样： Command Target value open / click btnAlert assertAlert I’m blocking! verifyTextPresent Alert is gone. 您可能会想“这很奇怪，我从未试图断言该警报。”但这是Selenium-IDE处理并为您关闭警报。如果您删除该步骤并重播测试，您将获得以下内容 [error] Error: There was an unexpected Alert! [I&#39;m blocking!]. 如果您只想声明警报存在但是不知道或不关心它包含哪个文本，则可以使用assertAlertPresent。这将返回true或false，错误地停止测试。 Confirmations确认的行为与警报的行为大致相同，其中assertConfirmation和assertConfirmationPresent提供与其警报对应物相同的特征。但是，默认情况下，Selenium会在弹出确认时选择“确定”。尝试单击示例页面中的“显示确认框”按钮，但单击弹出窗口中的“取消”按钮，然后断言输出文本。您的测试可能如下所示： Command Target value open / click btnAlert chooseCancelOnNextConfirmation assertConfirmation Choose an option. verifyTextPresent Rejected chooseCancelOnNextConfirmation函数告诉Selenium所有后续确认都应该返回false。可以通过调用chooseOkOnNextConfirmation来重置它。 可能会注意到您无法重播此测试，因为Selenium抱怨存在未经处理的确认。这是因为Selenium-IDE记录的事件顺序导致click和chooseCancelOnNextConfirmation被置于错误的顺序（如果考虑它就有意义，Selenium在打开确认之前无法知道正在取消）切换这两个命令，你的测试运行正常。 Prompts提示的行为与警报的行为大致相同，其中assertPrompt和assertPromptPresent提供与其警报对应项相同的特征。默认情况下，Selenium会在弹出提示时等待您输入数据。尝试单击示例页面中的“显示提示”按钮，然后在提示中输入“Selenium”。测试可能如下所示： Command Target value open / answerOnNextPrompt Selenium! click id=btnPrompt assertPrompt What’s the best web QA tool? verifyTextPresent Selenium! 如果在提示中选择取消，您可能会注意到answerOnNextPrompt只显示空白目标。 Selenium对取消和提示上的空白条目基本上是一样的。 调试断点要设置断点，请选择一个命令，单击鼠标右键，然后从上下文菜单中选择“切换断点”。然后单击“运行”按钮以从开始到断点运行测试用例。从测试用例的中间位置到结束位置运行测试用例或者到达起始点之后的断点有时也很有用。例如，假设您的测试用例首先登录到网站，然后执行一系列测试，并且您正在尝试调试其中一个测试。但是，您只需要登录一次，但是在开发测试时需要不断重新运行测试。您可以登录一次，然后从测试用例的登录部分之后的起点运行测试用例。这将阻止您每次重新运行测试用例时都必须手动注销。 按步骤执行测试要一次执行一个测试用例（“step through”），只需重复按此按钮。 Find Button“查找”按钮用于查看当前显示的网页（在浏览器中）中当前选定的Selenium命令中使用的UI元素。在为命令的第一个参数构建定位器时，这非常有用（请参阅定位元素一节）。它可以与标识网页上UI元素的任何命令一起使用，例如，单击，单击和等待，键入，以及某些断言和验证命令等。 从表视图中，选择具有locator参数的任何命令。单击“查找”按钮。现在查看网页：应该有一个明亮的绿色矩形，包围locator参数指定的元素。 Java中应用Selenium项目地址 我在本地录制了一个简单的脚本，选择导出到java+junit，类似下面：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class SearchGoogle &#123; private WebDriver driver; private boolean acceptNextAlert = true; private StringBuffer verificationErrors = new StringBuffer(); private SeleniumConfigure seleniumConfigure = SeleniumConfigureParse.getSeleniumConfigure(); @Before public void setUp() &#123; driver = DriverUtil.getDriver(); driver .manage().window().maximize();//全屏 driver.manage().timeouts().implicitlyWait(30, TimeUnit.SECONDS); &#125; @Test public void testSearchGoogle() &#123; driver.get(seleniumConfigure.getBaseUrl()); driver.findElement(By.name("q")).click(); driver.findElement(By.name("q")).clear(); driver.findElement(By.name("q")).sendKeys("google"); driver.findElement(By.name("q")).sendKeys(Keys.ENTER); &#125; @After public void tearDown() &#123; driver.quit(); String verificationErrorString = verificationErrors.toString(); if (!"".equals(verificationErrorString)) &#123; fail(verificationErrorString); &#125; &#125; private boolean isElementPresent(By by) &#123; try &#123; driver.findElement(by); return true; &#125; catch (NoSuchElementException e) &#123; return false; &#125; &#125; private boolean isAlertPresent() &#123; try &#123; driver.switchTo().alert(); return true; &#125; catch (NoAlertPresentException e) &#123; return false; &#125; &#125; private String closeAlertAndGetItsText() &#123; try &#123; Alert alert = driver.switchTo().alert(); String alertText = alert.getText(); if (acceptNextAlert) &#123; alert.accept(); &#125; else &#123; alert.dismiss(); &#125; return alertText; &#125; finally &#123; acceptNextAlert = true; &#125; &#125;&#125; 新建项目，pom.xml如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283 &lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;choerodon&lt;/groupId&gt; &lt;artifactId&gt;selenium&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt; &lt;artifactId&gt;selenium-server&lt;/artifactId&gt; &lt;version&gt;3.14.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.yaml/snakeyaml --&gt; &lt;dependency&gt; &lt;groupId&gt;org.yaml&lt;/groupId&gt; &lt;artifactId&gt;snakeyaml&lt;/artifactId&gt; &lt;version&gt;1.23&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt; &lt;!--&lt;dependency&gt;--&gt; &lt;!--&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;--&gt; &lt;!--&lt;artifactId&gt;lombok&lt;/artifactId&gt;--&gt; &lt;!--&lt;version&gt;1.18.4&lt;/version&gt;--&gt; &lt;!--&lt;scope&gt;provided&lt;/scope&gt;--&gt; &lt;!--&lt;/dependency&gt;--&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.5&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0-M3&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.maven.surefire&lt;/groupId&gt; &lt;artifactId&gt;surefire-junit47&lt;/artifactId&gt; &lt;version&gt;3.0.0-M3&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;configuration&gt; &lt;outputDirectory&gt;$&#123;basedir&#125;/output&lt;/outputDirectory&gt; &lt;outputName&gt;测试报告&lt;/outputName&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!--&lt;plugin&gt;--&gt; &lt;!--&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;--&gt; &lt;!--&lt;artifactId&gt;maven-site-plugin&lt;/artifactId&gt;--&gt; &lt;!--&lt;version&gt;2.1&lt;/version&gt;--&gt; &lt;!--&lt;configuration&gt;--&gt; &lt;!--&lt;outputDirectory&gt;$&#123;basedir&#125;/output&lt;/outputDirectory&gt;--&gt; &lt;!--&lt;outputName&gt;测试报告&lt;/outputName&gt;--&gt; &lt;!--&lt;/configuration&gt;--&gt; &lt;!--&lt;/plugin&gt;--&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 与Docker结合 使用远程的驱动服务来测试，目前只支持Chrome和FireFox，本地如果要起服务，请在docker中执行下面的命令启动服务 123docker pull elgalu/seleniumdocker run -d --name=grid -p 4444:24444 -p 5900:25900 -e TZ="Asia/Shanghai" -e MAX_INSTANCES=20 -e MAX_SESSIONS=20 -v /Users/dinghuang/Documents/Tool/selenium/shm:/dev/shm --privileged elgalu/seleniumdocker exec grid wait_all_done 30s 可以在http://localhost:4444/grid/console中查看详情 关闭服务命令： 12docker exec grid stopdocker stop grid 在JAVA代码中，可以通过远程的docker容器启动浏览器进行测试 1webDriver = new RemoteWebDriver(new URL("http://localhost:4444/wd/hub"), browser);]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在GitHub Page使用HEXO搭建博客]]></title>
    <url>%2F2018%2F09%2F21%2F%E5%A6%82%E4%BD%95%E5%9C%A8GitHub%20Page%E4%BD%BF%E7%94%A8HEXO%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[如何在使用GitHub Page搭建HEXO博客项目地址 准备工作 安装Git 安装Node.js 注册Github账号 创建新的仓库 名称必须为 用户名.github.io 添加本地电脑的SSH认证，如图所示在本地命令工具中输入ssh-keygen -t rsa -C &quot;Github的注册邮箱地址&quot;一路回车之后会得到两个文件：id_rsa和id_rsa.pub，然后用带格式的编辑器（比方说notepad++或者sublime）打开id_rsa.pub，复制里面的所有内容，然粘贴到KEY里面。 安装HEXO 打开命令行工具npm install -g hexo-cli 安装 Hexo 完成后，分步执行（即输入代码之后敲回车）下列命令，Hexo 将会在指定文件夹中新建所需要的文件。hexo init &lt;folder&gt;在文件夹内执行npm install 成功后，博客项目成功初始化 配置NEXT主题 安装NEXT主题 mkdir themes/nextcurl -s https://api.github.com/repos/iissnan/hexo-theme-next/releases/latest | grep tarball_url | cut -d &#39;&quot;&#39; -f 4 | wget -i - -O- | tar -zx -C themes/next --strip-components=1修改站点配置文件_config.yml12345678910111213141516title: 一只病猫subtitle: 静坐常思己过，闲谈莫论人非description: 学习、生活、闲谈、足球author: 强壮的病猫language: zh-Hanstimezone: Asia/Shanghaitheme: nexturl: https://dinghuang.github.io/deploy: type: git repo: https://github.com/dinghuang/dinghuang.github.io.git branch: master#开启swiftype搜索，后面的id在swiftype官网申请，[具体操作][3]swiftype_key: HcRPHRrBuwozvgUoLNyX#要放到仓库的静态资源都放在source文件夹中，.md会被转换成HTML，所以这里要忽略skip_render: README.md 配置NEXT主题设置主题配置文件./themes/next/_config.yml，可以参考本项目的配置。NEXT强大之处在于继承了很多第三方服务插件，不过类似评论搜索功能的插件被墙了，外网是可以用的。具体参考 设置标签分类参考链接，在文章开头，引入：12345title: 设计模式date: 2018-07-18 09:43:00tags: - JAVAcategories: JAVA 更多配置请参考官方文档 提交 输入命令npm install hexo-deployer-git --save 创建文章hexo new &quot;你想要的文章标题填在这个双引号里&quot; 文章会生成在./source/_posts/设计模式.md进行修改后hexo clean ; hexo genarate 然后输入hexo deploy此时文章已经成功部署。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VPS搭建SS]]></title>
    <url>%2F2018%2F09%2F08%2FVPS%E6%90%AD%E5%BB%BASS%2F</url>
    <content type="text"><![CDATA[购买VPS服务器声明：本教程仅供学习用 购买地址 推荐vultr的原因是，vultr支持支付宝、服务器较多，价格虽然不算便宜，但是网速稳定。各个机房速度测试，直接ping 域名地理位置 官方测试服务器ip 下载测试文件123456789101112131415Frankfurt, DE fra-de-ping.vultr.com 100M 1000MAmsterdam, NL ams-nl-ping.vultr.com 100M 1000MParis, France par-fr-ping.vultr.com 100M 1000MLondon, UK lon-gb-ping.vultr.com 100M 1000MSingapore sgp-ping.vultr.com 100M 1000MNew York (NJ) nj-us-ping.vultr.com 100M 1000MTokyo, Japan hnd-jp-ping.vultr.com 100M 1000MChicago, Illinois il-us-ping.vultr.com 100M 1000MAtlanta, Georgia ga-us-ping.vultr.com 100M 1000MMiami, Florida fl-us-ping.vultr.com 100M 1000MSeattle, Washington wa-us-ping.vultr.com 100M 1000MDallas, Texas tx-us-ping.vultr.com 100M 1000MSilicon Valley, California sjo-ca-us-ping.vultr.com 100M 1000MLos Angeles, California lax-ca-us-ping.vultr.com 100M 1000MSydney, Australia syd-au-ping.vultr.com 100M 1000M 经过测试，大陆地区，Tokyo的速度是最快的，延迟在50ms左右。 搭建ShadowSocksR服务ssh连接购买的服务器ssh -p22 root@xx.xx.xx.xx搭建ssr服务wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.shchmod +x shadowsocksR.sh./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log根据提示输入相关配置相关指令：卸载: ./shadowsocksR.sh uninstall启动：/etc/init.d/shadowsocks start停止：/etc/init.d/shadowsocks stop重启：/etc/init.d/shadowsocks restart状态：/etc/init.d/shadowsocks status配置文件路径：/etc/shadowsocks.json日志文件路径：/var/log/shadowsocks.log代码安装目录：/usr/local/shadowsocks如果要配置多个用户，多个端口，打开配置文件路径，修改如下：1234567891011121314151617&#123; "server":"0.0.0.0", "server_ipv6":"[::]", "server_port":9001, "local_address":"127.0.0.1", "local_port":1080, "port_password":&#123; "9001":"123456", "9002":"123456", "9003":"123456" &#125;, "timeout":300, "method":"aes-256-cfb", "protocol":"origin", "obfs":"plain", "fast_open":false&#125; 设置相关端口后要在防火墙打开相关端口的通讯，Centos默认使用firewall命令，如下所示：sudo firewall-cmd --zone=public --add-port=3000/tcp --permanentsudo firewall-cmd --reloadfirewall-cmd --list-all 优化网络1.系统层面vi /etc/sysctl.conf 123456789101112131415161718192021222324252627282930313233343536373839404142# max open filesfs.file-max = 1024000# max read buffernet.core.rmem_max = 67108864# max write buffernet.core.wmem_max = 67108864# default read buffernet.core.rmem_default = 65536# default write buffernet.core.wmem_default = 65536# max processor input queuenet.core.netdev_max_backlog = 4096# max backlognet.core.somaxconn = 4096# resist SYN flood attacksnet.ipv4.tcp_syncookies = 1# reuse timewait sockets when safenet.ipv4.tcp_tw_reuse = 1# turn off fast timewait sockets recyclingnet.ipv4.tcp_tw_recycle = 0# short FIN timeoutnet.ipv4.tcp_fin_timeout = 30# short keepalive timenet.ipv4.tcp_keepalive_time = 1200# outbound port rangenet.ipv4.ip_local_port_range = 10000 65000# max SYN backlognet.ipv4.tcp_max_syn_backlog = 4096# max timewait sockets held by system simultaneouslynet.ipv4.tcp_max_tw_buckets = 5000# TCP receive buffernet.ipv4.tcp_rmem = 4096 87380 67108864# TCP write buffernet.ipv4.tcp_wmem = 4096 65536 67108864# turn on path MTU discoverynet.ipv4.tcp_mtu_probing = 1# for high-latency networknet.ipv4.tcp_congestion_control = htcp# forward ipv4net.ipv4.ip_forward = 1 保存生效sysctl -p其中最后的hybla是为高延迟网络（如美国，欧洲）准备的算法，需要内核支持，测试内核是否支持，在终端输入：sysctl net.ipv4.tcp_available_congestion_control如果结果中有hybla，则证明你的内核已开启hybla，如果没有hybla，可以用命令modprobe tcp_hybla开启。 对于低延迟的网络（如日本，香港等），可以使用htcp，可以非常显著的提高速度，首先使用modprobe tcp_htcp开启，再将net.ipv4.tcp_congestion_control = hybla改为net.ipv4.tcp_congestion_control = htcp，建议EC2日本用户使用这个算法。 2.TCP优化1.修改文件句柄数限制如果是ubuntu/centos均可修改/etc/sysctl.conf找到fs.file-max这一行，修改其值为1024000，并保存退出。然后执行sysctl -p使其生效修改vi /etc/security/limits.conf文件，加入 12* soft nofile 512000* hard nofile 1024000 针对centos,还需要修改vi /etc/pam.d/common-session文件，加入session required pam_limits.so 2.修改vi /etc/profile文件，加入ulimit -SHn 1024000然后重启服务器执行ulimit -n，查询返回1024000即可。 sysctl.conf报错解决方法修复modprobe的：12rm -f /sbin/modprobe ln -s /bin/true /sbin/modprobe 修复sysctl的：12rm -f /sbin/sysctl ln -s /bin/true /sbin/sysctl 3.软件辅助优化软件辅助优化都得参考系统内核，查看是否适用，如果不适用，可以修改系统内核。 2.1 锐速 锐速是TCP底层加速软件,官方已停止推出永久免费版本,但网上有破解版可以继续使用。需要购买的话先到锐速官网注册帐号,并确认内核版本是否支持锐速的版本。 一键安装速锐破解版 wget -N --no-check-certificate https://github.com/91yun/serverspeeder/raw/master/serverspeeder.sh &amp;&amp; bash serverspeeder.sh一键卸载 chattr -i /serverspeeder/etc/apx* &amp;&amp; /serverspeeder/bin/serverSpeeder.sh uninstall -f设置 12345Enter your accelerated interface(s) [eth0]: eth0Enter your outbound bandwidth [1000000 kbps]: 1000000Enter your inbound bandwidth [1000000 kbps]: 1000000Configure shortRtt-bypass [0 ms]: 0Auto load ServerSpeeder on linux start-up? [n]:y 是否开机自启Run ServerSpeeder now? [y]:y #是否现在启动执行lsmod，看到有appex0模块即说明锐速已正常安装并启动。 至此，安装就结束了，但还有后续配置。修改vi /serverspeeder/etc/config文件的几个参数以使锐速更好的工作 123456accppp="1" #加速PPTP、L2TP V-P-N；设为1表示开启，设为0表示关闭advinacc="1" #高级入向加速开关；设为 1 表示开启，设为 0 表示关闭；开启此功能可以得到更好的流入方向流量加速效果；maxmode="1" #最大传输模式；设为 1 表示开启；设为 0 表示关闭；开启后会进一步提高加速效果，但是可能会降低有效数据率。rsc="1" #网卡接收端合并开关；设为 1 表示开启，设为 0 表示关闭；在有些较新的网卡驱动中，带有 RSC 算法的，需要打开该功能。l2wQLimit="512 4096" #从 LAN 到 WAN 加速引擎在缓冲池充满和空闲时分别能够缓存的数据包队列的长度的上限；该值设置的高会获得更好的加速效果，但是会消耗更多的内存w2lQLimit="512 4096" #从 WAN 到 LAN 加速引擎在缓冲池充满和空闲时分别能够缓存的数据包队列的长度的上限；该值设置的高会获得更好的加速效果，但是会消耗更多的内存 重读配置以使配置生效/serverspeeder/bin/serverSpeeder.sh reload 查看锐速当前状态/serverspeeder/bin/serverSpeeder.sh stats 查看所有命令/serverspeeder/bin/serverSpeeder.sh help 停止/serverspeeder/bin/serverSpeeder.sh stop 启动/serverspeeder/bin/serverSpeeder.sh start 重启锐速/serverspeeder/bin/serverSpeeder.sh restart 2.1 安装Google BBR 要求内核版本4.13.5-1.el7.elrepo.x86_64 以上12rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpmyum --enablerepo=elrepo-kernel install kernel-ml -y 检查内核是否更新rpm -qa | grep kernel启动grub2-set-default 1重启shutdown -r now查看是否生效uname -r安装Google BBR123echo 'net.core.default_qdisc=fq' | sudo tee -a /etc/sysctl.confecho 'net.ipv4.tcp_congestion_control=bbr' | sudo tee -a /etc/sysctl.confsysctl -p 检查是否安装成功sysctl net.ipv4.tcp_available_congestion_control执行命令后，看是否是提示“net.ipv4.tcp_available_congestion_control = bbr cubic reno”执行命令，是否提示bbrlsmod | grep bbr]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2018%2F07%2F18%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[菜鸟教程文档 设计模式设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。 代码案例 1.创建型模式这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 1.1. 工厂模式主要解决：主要解决接口选择的问题。 何时使用：我们明确地计划不同条件下创建不同实例时。 优点： 一个调用者想创建一个对象，只要知道其名称就可以了 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以 屏蔽产品的具体实现，调用者只关心产品的接口 缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。 如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。 使用场景： 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。 注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。 1234567891011121314151617181920212223242526272829303132public interface Car &#123; void run();&#125;public class ExpensiveCar implements Car &#123; @Override public void run() &#123; System.out.println("expensiveCar.run"); &#125;&#125;public class LitterCar implements Car &#123; @Override public void run() &#123; System.out.println("littleCard.run"); &#125;&#125;public class CarFactory &#123; public Car getCar(String type) &#123; if (type == null) &#123; return null; &#125; if (type.equals("litterCar")) &#123; return new LitterCar(); &#125; else if (type.equals("ExpensiveCar")) &#123; return new ExpensiveCar(); &#125; return null; &#125;&#125; 1.2. 抽象工厂模式主要解决：主要解决接口选择的问题。 何时使用：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。 优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。 缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。 使用场景： 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。 注意事项：产品族难扩展，产品等级易扩展。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public interface Car &#123; void run();&#125;public class ExpensiveCar implements Car &#123; @Override public void run() &#123; System.out.println("expensiveCar.run"); &#125;&#125;public class LitterCar implements Car &#123; @Override public void run() &#123; System.out.println("littleCard.run"); &#125;&#125;public interface Passengers &#123; void getCar();&#125;public class Man implements Passengers &#123; @Override public void getCar() &#123; System.out.println("man.getCar"); &#125;&#125;public class Woman implements Passengers &#123; @Override public void getCar() &#123; System.out.println("man.getCar"); &#125;&#125;public abstract class AbstractFactory &#123; public abstract Passengers getPassengers(String user); public abstract Car getCar(String car);&#125;public class CarFactory extends AbstractFactory&#123; @Override public Passengers getPassengers(String user) &#123; return null; &#125; @Override public Car getCar(String type) &#123; if (type == null) &#123; return null; &#125; if (type.equals("litterCar")) &#123; return new LitterCar(); &#125; else if (type.equals("ExpensiveCar")) &#123; return new ExpensiveCar(); &#125; return null; &#125;&#125;public class PassengerFactory extends AbstractFactory &#123; @Override public Passengers getPassengers(String user) &#123; if (user == null) &#123; return null; &#125; if (user.equals("man")) &#123; return new Man(); &#125; else if (user.equals("woman")) &#123; return new Woman(); &#125; return null; &#125; @Override public Car getCar(String car) &#123; return null; &#125;&#125;public class FactoryProducer &#123; public static AbstractFactory getFactory(String choice) &#123; if (choice.equalsIgnoreCase("Car")) &#123; return new CarFactory(); &#125; else if (choice.equalsIgnoreCase("Passenger")) &#123; return new PassengerFactory(); &#125; return null; &#125;&#125; 1.3. 单例模式主要解决：一个全局使用的类频繁地创建与销毁。 何时使用：当您想控制实例数目，节省系统资源的时候。 优点： 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存） 避免对资源的多重占用（比如写文件操作） 缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。 使用场景： 要求生产唯一序列号。 WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。 注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205/** * 饿汉式 * 是否 Lazy 初始化：否 * &lt;p&gt; * 是否多线程安全：是 * &lt;p&gt; * 实现难度：易 * &lt;p&gt; * 描述：这种方式比较常用，但容易产生垃圾对象。 * 优点：没有加锁，执行效率会提高。 * 缺点：类加载时就初始化，浪费内存。 * 它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多 * 种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载， * 这时候初始化 instance 显然没有达到 lazy loading 的效果。 * * @author dinghuang123@gmail.com * @since 2018/7/18 */public class User &#123; private static User user = new User(); //让构造函数私有化，这样该类不会被实例化 private User() &#123; &#125; public static User getUser() &#123; return user; &#125; public void showMessage() &#123; System.out.println("What???"); &#125;&#125;/** * 懒汉式，线程不安全 * 是否 Lazy 初始化：是 * &lt;p&gt; * 是否多线程安全：否 * &lt;p&gt; * 实现难度：易 * &lt;p&gt; * 描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。 * 这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。 * * @author dinghuang123@gmail.com * @since 2018/7/18 */public class User &#123; private static User user; //让构造函数私有化，这样该类不会被实例化 private User() &#123; &#125; public static User getUser() &#123; if (user == null) &#123; System.out.println("no user"); user = new User(); &#125; return user; &#125; public void showMessage() &#123; System.out.println("What???"); &#125;&#125;/** * 懒汉式，线程安全 * 是否 Lazy 初始化：是 * &lt;p&gt; * 是否多线程安全：是 * &lt;p&gt; * 实现难度：易 * &lt;p&gt; * 描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。 * 优点：第一次调用才初始化，避免内存浪费。 * 缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。 * getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。 * * @author dinghuang123@gmail.com * @since 2018/7/18 */public class User &#123; private static User user; //让构造函数私有化，这样该类不会被实例化 private User() &#123; &#125; public static synchronized User getUser() &#123; if (user == null) &#123; System.out.println("no User"); user = new User(); &#125; return user; &#125; public void showMessage() &#123; System.out.println("What???"); &#125;&#125;/** * 双检锁/双重校验锁（DCL，即 double-checked locking） * JDK 版本：JDK1.5 起 * &lt;p&gt; * 是否 Lazy 初始化：是 * &lt;p&gt; * 是否多线程安全：是 * &lt;p&gt; * 实现难度：较复杂 * &lt;p&gt; * 描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。 * getInstance() 的性能对应用程序很关键。 * * @author dinghuang123@gmail.com * @since 2018/7/18 */public class User &#123; private static User user; //让构造函数私有化，这样该类不会被实例化 private User() &#123; &#125; public static User getUser() &#123; if (user == null) &#123; synchronized (User.class) &#123; if (user == null) &#123; System.out.println("no User"); user = new User(); &#125; &#125; &#125; return user; &#125; public void showMessage() &#123; System.out.println("What???"); &#125;&#125;/** * 登记式/静态内部类 * 是否 Lazy 初始化：是 * &lt;p&gt; * 是否多线程安全：是 * &lt;p&gt; * 实现难度：一般 * &lt;p&gt; * 描述：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式 * 。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。 * 这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是： * 第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果） * ，而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用， * 只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下， * 如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载 * 时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实 * 例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。 * * @author dinghuang123@gmail.com * @since 2018/7/18 */public class User &#123; private static class UserHolder &#123; private static final User user = new User(); &#125; private User() &#123; &#125; public static final User getUser() &#123; return UserHolder.user; &#125;&#125;public class SingletonTest &#123; public static void main(String[] args) &#123; //不合法的构造函数 //编译时错误：构造函数 User() 是私有的// User user = new User(); Runnable runnable = () -&gt; &#123; //枚举单例// User.USER.sendMessage(); User user = User.getUser(); user.showMessage(); &#125;; IntStream.range(0, 100) .forEach(i -&gt; &#123; Thread thread = new Thread(runnable); thread.start(); &#125;); &#125;&#125; 一般情况下，不建议使用懒汉方式，建议使用饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用登记方式。如果涉及到反序列化创建对象时，可以尝试使用枚举方式。如果有其他特殊的需求，可以考虑使用双检锁方式。 1.4. 建造者模式建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。 主要解决：主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。 何时使用：一些基本部件不会变，而其组合经常变化的时候。 如何解决：将变与不变分离开。 应用实例： 去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的”套餐” JAVA 中的 StringBuilder 优点： 建造者独立，易扩展 便于控制细节风险 缺点： 产品必须有共同点，范围有限制 如内部变化复杂，会有很多的建造类 使用场景： 需要生成的对象具有复杂的内部结构 需要生成的对象内部属性本身相互依赖 注意事项：与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126public interface Product &#123; public String name(); public float price(); public Production production();&#125;public interface Production &#123; public String production();&#125;public class Hand implements Production&#123; @Override public String production() &#123; return "hand"; &#125;&#125;public class Machine implements Production &#123; @Override public String production() &#123; return "Machine"; &#125;&#125;public abstract class Windows implements Product&#123; @Override public Production production()&#123; return new Hand(); &#125; @Override public abstract float price();&#125;public abstract class Mac implements Product&#123; @Override public Production production()&#123; return new Machine(); &#125; @Override public abstract float price();&#125;public class WindowsSystem extends Windows&#123; @Override public String name() &#123; return "windowsSystem"; &#125; @Override public float price() &#123; return 25.0f; &#125;&#125;public class MacSystem extends Mac &#123; @Override public String name() &#123; return "macSystem"; &#125; @Override public float price() &#123; return 30.0f; &#125;&#125;public class SystemProduct &#123; private List&lt;Product&gt; products = new ArrayList&lt;&gt;(); public void addProduct(Product product) &#123; products.add(product); &#125; public float getCost() &#123; float cost = 0.0f; for (Product product : products) &#123; cost += product.price(); &#125; return cost; &#125; public void showProducts() &#123; for (Product product : products) &#123; System.out.print("Product : " + product.name()); System.out.print(",Production : " + product.production().production()); System.out.println(", Price : " + product.price()); &#125; &#125;&#125;public class SystemProductBuilder &#123; public SystemProduct prepareMacSystem() &#123; SystemProduct systemProduct = new SystemProduct(); systemProduct.addProduct(new MacSystem()); return systemProduct; &#125; public SystemProduct prepareWindowsSystem() &#123; SystemProduct systemProduct = new SystemProduct(); systemProduct.addProduct(new WindowsSystem()); return systemProduct; &#125;&#125;public class BuilderTest &#123; public static void main(String[] args) &#123; SystemProductBuilder systemProductBuilder = new SystemProductBuilder(); SystemProduct windows = systemProductBuilder.prepareMacSystem(); System.out.println("windows product"); windows.showProducts(); System.out.println("Total Cost: " + windows.getCost()); SystemProduct allSystem = systemProductBuilder.prepareAllSystem(); System.out.println("allSystem"); allSystem.showProducts(); System.out.println("Total Cost: " + allSystem.getCost()); &#125;&#125; 1.5. 原型模式原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。 主要解决：在运行期建立和删除原型。 何时使用： 当一个系统应该独立于它的产品创建，构成和表示时 当要实例化的类是在运行时刻指定时，例如，通过动态装载 为了避免创建一个与产品类层次平行的工厂类层次时 当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些 如何解决：利用已有的一个原型对象，快速地生成和原型对象一样的实例。 应用实例： 细胞分裂 JAVA 中的 Object clone() 方法 优点： 性能提高 逃避构造函数的约束 缺点： 配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候 必须实现 Cloneable 接口 使用场景： 资源优化场景 类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等 性能和安全要求的场景 通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式 一个对象多个修改者的场景 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用 在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用 注意事项：与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/** * 创建一个抽象类 Prototype 和扩展了 Prototype 类的实体类。下一步是定义类 PrototypeCache，该类把 Prototype * 对象存储在一个 Hashtable 中，并在请求的时候返回它们的克隆。 * * @author dinghuang123@gmail.com * @since 2018/7/18 */public abstract class Prototype implements Cloneable&#123; private String id; private String type; abstract void operation(); public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getType() &#123; return type; &#125; public void setType(String type) &#123; this.type = type; &#125; @Override public Object clone()&#123; Object clone = null; try&#123; clone = super.clone(); &#125;catch (CloneNotSupportedException e)&#123; e.printStackTrace(); &#125; return clone; &#125;&#125;public class PrototypeOne extends Prototype &#123; public PrototypeOne()&#123; type = "prototypeOne"; &#125; @Override void operation() &#123; System.out.println("Inside PrototypeOne::draw() method."); &#125;&#125;public class PrototypeTwo extends Prototype &#123; public PrototypeTwo() &#123; type = "prototypeTwo"; &#125; @Override void operation() &#123; System.out.println("Inside PrototypeTwo::draw() method."); &#125;&#125;public class PrototypeCache &#123; private static Hashtable&lt;String,Prototype&gt; propertyMap = new Hashtable&lt;&gt;(); public static Prototype getProperType(String id)&#123; Prototype cachePrototype = propertyMap.get(id); return (Prototype) cachePrototype.clone(); &#125; public static void loadCache() &#123; PrototypeOne prototypeOne = new PrototypeOne(); prototypeOne.setId("1"); propertyMap.put(prototypeOne.getId(),prototypeOne); PrototypeTwo prototypeTwo = new PrototypeTwo(); prototypeTwo.setId("2"); propertyMap.put(prototypeTwo.getId(),prototypeTwo); &#125;&#125;public class PrototypeTest &#123; public static void main(String[] args) &#123; PrototypeCache.loadCache(); PrototypeOne prototypeOne = (PrototypeOne) PrototypeCache.getProperType("1"); System.out.println("Prototype : " + prototypeOne.getType()); PrototypeTwo prototypeTwo = (PrototypeTwo) PrototypeCache.getProperType("2"); System.out.println("Prototype : " + prototypeTwo.getType()); &#125;&#125; 2.结构型模式这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。 2.1. 适配器模式适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。 这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。 我们通过下面的实例来演示适配器模式的使用。其中，音频播放器设备只能播放 mp3 文件，通过使用一个更高级的音频播放器来播放 vlc 和 mp4 文件。 主要解决：主要解决在软件系统中，常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。 何时使用： 系统需要使用现有的类，而此类的接口不符合系统的需要 想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口 通过接口转换，将一个类插入另一个类系中（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口） 如何解决：继承或依赖（推荐）。 应用实例： 美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式 在 LINUX 上运行 WINDOWS 程序 JAVA 中的 jdbc 优点： 可以让任何两个没有关联的类一起运行 提高了类的复用 增加了类的透明度 灵活性好 缺点： 过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构 由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类 使用场景：有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。 注意事项：适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public interface MediaPlayer &#123; public void play(String audioType, String fileName);&#125;public interface AdvancedMediaPlayer &#123; public void playVlc(String fileName); public void playMp4(String fileName);&#125;public class VlcPlayer implements AdvancedMediaPlayer &#123; @Override public void playVlc(String fileName) &#123; System.out.println("Playing vlc file. Name: " + fileName); &#125; @Override public void playMp4(String fileName) &#123; //do nothing &#125;&#125;public class Mp4Player implements AdvancedMediaPlayer &#123; @Override public void playVlc(String fileName) &#123; //do Nothing &#125; @Override public void playMp4(String fileName) &#123; System.out.println("Playing mp4 file. Name: " + fileName); &#125;&#125;public class MediaAdapter implements MediaPlayer &#123; AdvancedMediaPlayer advancedMusicPlayer; public MediaAdapter(String audioType) &#123; if (audioType.equalsIgnoreCase("vlc")) &#123; advancedMusicPlayer = new VlcPlayer(); &#125; else if (audioType.equalsIgnoreCase("mp4")) &#123; advancedMusicPlayer = new Mp4Player(); &#125; &#125; @Override public void play(String audioType, String fileName) &#123; if (audioType.equalsIgnoreCase("vlc")) &#123; advancedMusicPlayer.playVlc(fileName); &#125; else if (audioType.equalsIgnoreCase("mp4")) &#123; advancedMusicPlayer.playMp4(fileName); &#125; &#125;&#125;public class AudioPlayer implements MediaPlayer &#123; MediaAdapter mediaAdapter; @Override public void play(String audioType, String fileName) &#123; //播放 mp3 音乐文件的内置支持 if(audioType.equalsIgnoreCase("mp3"))&#123; System.out.println("Playing mp3 file. Name: "+ fileName); &#125; //mediaAdapter 提供了播放其他文件格式的支持 else if(audioType.equalsIgnoreCase("vlc") || audioType.equalsIgnoreCase("mp4"))&#123; mediaAdapter = new MediaAdapter(audioType); mediaAdapter.play(audioType, fileName); &#125; else&#123; System.out.println("Invalid media. "+ audioType + " format not supported"); &#125; &#125;&#125;public class AdapterTest &#123; public static void main(String[] args) &#123; AudioPlayer audioPlayer = new AudioPlayer(); audioPlayer.play("mp3", "beyond the horizon.mp3"); audioPlayer.play("mp4", "alone.mp4"); audioPlayer.play("vlc", "far far away.vlc"); audioPlayer.play("avi", "mind me.avi"); &#125;&#125; 2.2. 桥接模式桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。 这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。 主要解决：在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。 何时使用：实现系统可能有多个角度分类，每一种角度都可能变化。 如何解决：把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。 应用实例： 猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择 墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的 优点： 抽象和实现的分离 优秀的扩展能力 实现细节对客户透明 缺点：桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。 使用场景： 如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系 对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用 一个类存在两个独立变化的维度，且这两个维度都需要进行扩展 注意事项：对于两个独立变化的维度，使用桥接模式再适合不过了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public interface DrawAPI &#123; public void drawCircle(int radius, int x, int y);&#125;public class RedCircle implements DrawAPI &#123; @Override public void drawCircle(int radius, int x, int y) &#123; System.out.println("Drawing Circle[ color: red, radius: " + radius +", x: " +x+", "+ y +"]"); &#125;&#125;public class GreenCircle implements DrawAPI &#123; @Override public void drawCircle(int radius, int x, int y) &#123; System.out.println("Drawing Circle[ color: green, radius: " + radius + ", x: " + x + ", " + y + "]"); &#125;&#125;public abstract class Shape &#123; protected DrawAPI drawAPI; protected Shape(DrawAPI drawAPI) &#123; this.drawAPI = drawAPI; &#125; public abstract void draw();&#125;public class Circle extends Shape &#123; private int x, y, radius; public Circle(int x, int y, int radius, DrawAPI drawAPI) &#123; super(drawAPI); this.x = x; this.y = y; this.radius = radius; &#125; @Override public void draw() &#123; drawAPI.drawCircle(radius, x, y); &#125;&#125;public class BridgeTest &#123; public static void main(String[] args) &#123; Shape redCircle = new Circle(100, 100, 10, new RedCircle()); Shape greenCircle = new Circle(100, 100, 10, new GreenCircle()); redCircle.draw(); greenCircle.draw(); &#125;&#125; 2.3. 桥接模式过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）是一种设计模式，这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。这种类型的设计模式属于结构型模式，它结合多个标准来获得单一标准。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136public class Person &#123; private String name; private String gender; private String maritalStatus; public Person(String name,String gender,String maritalStatus)&#123; this.name = name; this.gender = gender; this.maritalStatus = maritalStatus; &#125; public String getName() &#123; return name; &#125; public String getGender() &#123; return gender; &#125; public String getMaritalStatus() &#123; return maritalStatus; &#125; &#125;public interface Criteria &#123; public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons);&#125;public class CriteriaMale implements Criteria &#123; @Override public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123; return persons.stream().filter(person -&gt; person.getGender() .equalsIgnoreCase("MALE")).collect(Collectors.toList()); &#125;&#125;public class CriteriaFemale implements Criteria &#123; @Override public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123; return persons.stream().filter(person -&gt; person.getGender() .equalsIgnoreCase("FEMALE")).collect(Collectors.toList()); &#125;&#125;public class CriteriaSingle implements Criteria &#123; @Override public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123; return persons.stream().filter(person -&gt; person.getMaritalStatus() .equalsIgnoreCase("SINGLE")).collect(Collectors.toList()); &#125;&#125;public class AndCriteria implements Criteria &#123; private Criteria criteria; private Criteria otherCriteria; public AndCriteria(Criteria criteria, Criteria otherCriteria) &#123; this.criteria = criteria; this.otherCriteria = otherCriteria; &#125; @Override public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123; List&lt;Person&gt; firstCriteriaPersons = criteria.meetCriteria(persons); return otherCriteria.meetCriteria(firstCriteriaPersons); &#125;&#125;public class OrCriteria implements Criteria &#123; private Criteria criteria; private Criteria otherCriteria; public OrCriteria(Criteria criteria, Criteria otherCriteria) &#123; this.criteria = criteria; this.otherCriteria = otherCriteria; &#125; @Override public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123; List&lt;Person&gt; firstCriteriaItems = criteria.meetCriteria(persons); List&lt;Person&gt; otherCriteriaItems = otherCriteria.meetCriteria(persons); for (Person person : otherCriteriaItems) &#123; if(!firstCriteriaItems.contains(person))&#123; firstCriteriaItems.add(person); &#125; &#125; return firstCriteriaItems; &#125;&#125;public class CriteriaTest &#123; public static void main(String[] args) &#123; List&lt;Person&gt; persons = new ArrayList&lt;Person&gt;(); persons.add(new Person("Robert","Male", "Single")); persons.add(new Person("John","Male", "Married")); persons.add(new Person("Laura","Female", "Married")); persons.add(new Person("Diana","Female", "Single")); persons.add(new Person("Mike","Male", "Single")); persons.add(new Person("Bobby","Male", "Single")); Criteria male = new CriteriaMale(); Criteria female = new CriteriaFemale(); Criteria single = new CriteriaSingle(); Criteria singleMale = new AndCriteria(single, male); Criteria singleOrFemale = new OrCriteria(single, female); System.out.println("Males: "); printPersons(male.meetCriteria(persons)); System.out.println("\nFemales: "); printPersons(female.meetCriteria(persons)); System.out.println("\nSingle Males: "); printPersons(singleMale.meetCriteria(persons)); System.out.println("\nSingle Or Females: "); printPersons(singleOrFemale.meetCriteria(persons)); &#125; public static void printPersons(List&lt;Person&gt; persons)&#123; for (Person person : persons) &#123; System.out.println("Person : [ Name : " + person.getName() +", Gender : " + person.getGender() +", Marital Status : " + person.getMaritalStatus() +" ]"); &#125; &#125;&#125; 2.4. 组合模式组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。 这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。 我们通过下面的实例来演示组合模式的用法。实例演示了一个组织中员工的层次结构。 意图：将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。 主要解决：它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。 何时使用： 您想表示对象的部分-整体层次结构（树形结构） 您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象 如何解决：树枝和叶子实现统一接口，树枝内部组合该接口。 关键代码：树枝内部组合该接口，并且含有内部属性 List，里面放 Component。 应用实例： 算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作数、操作符和另一个操作数 在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝 优点： 高层模块调用简单 节点自由增加 缺点：在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。 使用场景：部分、整体场景，如树形菜单，文件、文件夹的管理。 注意事项：定义时为具体类。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class Employee &#123; private String name; private String dept; private int salary; private List&lt;Employee&gt; subordinates; //构造函数 public Employee(String name,String dept, int sal) &#123; this.name = name; this.dept = dept; this.salary = sal; subordinates = new ArrayList&lt;&gt;(); &#125; public void add(Employee e) &#123; subordinates.add(e); &#125; public void remove(Employee e) &#123; subordinates.remove(e); &#125; public List&lt;Employee&gt; getSubordinates()&#123; return subordinates; &#125; @Override public String toString() &#123; return MoreObjects.toStringHelper(this) .add("name", name) .add("dept", dept) .add("salary", salary) .add("subordinates", subordinates) .toString(); &#125;&#125;public class CompositeTest &#123; public static void main(String[] args) &#123; Employee CEO = new Employee("John", "CEO", 30000); Employee headSales = new Employee("Robert", "Head Sales", 20000); Employee headMarketing = new Employee("Michel", "Head Marketing", 20000); Employee clerk1 = new Employee("Laura", "Marketing", 10000); Employee clerk2 = new Employee("Bob", "Marketing", 10000); Employee salesExecutive1 = new Employee("Richard", "Sales", 10000); Employee salesExecutive2 = new Employee("Rob", "Sales", 10000); CEO.add(headSales); CEO.add(headMarketing); headSales.add(salesExecutive1); headSales.add(salesExecutive2); headMarketing.add(clerk1); headMarketing.add(clerk2); //打印该组织的所有员工 System.out.println(CEO); CEO.getSubordinates().forEach(employee -&gt; &#123; System.out.println(employee); employee.getSubordinates().forEach(System.out::println); &#125;); &#125;&#125; 2.5. 装饰器模式装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。 这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。 意图：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。 主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。 何时使用：在不想增加很多子类的情况下扩展类。 如何解决：将具体功能职责划分，同时继承装饰者模式。 关键代码： Component 类充当抽象角色，不应该具体实现 修饰类引用和继承 Component 类，具体扩展类重写父类方法。 应用实例： 孙悟空有 72 变，当他变成”庙宇”后，他的根本还是一只猴子，但是他又有了庙宇的功能 不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。 优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。 缺点：多层装饰比较复杂。 使用场景： 扩展一个类的功能 动态增加功能，动态撤销。 注意事项：可代替继承 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public interface Decorator &#123; void draw();&#125;public class CircleDecorator implements Decorator &#123; @Override public void draw() &#123; System.out.println("Decorator: CircleDecorator"); &#125;&#125;public class RedShapeDecorator extends ShapeDecorator &#123; public RedShapeDecorator(Decorator decorator) &#123; super(decorator); &#125; @Override public void draw() &#123; decorator.draw(); setRedBorder(decorator); &#125; private void setRedBorder(Decorator decorator) &#123; System.out.println("Border Color: Red"); &#125;&#125;public abstract class ShapeDecorator implements Decorator&#123; protected Decorator decorator ; public ShapeDecorator(Decorator decorator)&#123; this.decorator = decorator; &#125; @Override public void draw() &#123; decorator.draw(); &#125;&#125;public class Rectangle implements Decorator &#123; @Override public void draw() &#123; System.out.println("Decorator: Rectangle"); &#125;&#125;public class DecoratorTest &#123; public static void main(String[] args) &#123; Decorator circle = new CircleDecorator(); Decorator redCircle = new RedShapeDecorator(new CircleDecorator()); Decorator redRectangle = new RedShapeDecorator(new Rectangle()); System.out.println("Circle with normal border"); circle.draw(); out.println("\nCircle of red border"); redCircle.draw(); out.println("\nRectangle of red border"); redRectangle.draw(); &#125;&#125; 2.6. 外观模式外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。 这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。 意图：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 主要解决：降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。 何时使用： 客户端不需要知道系统内部的复杂联系，整个系统只需提供一个”接待员”即可 定义系统的入口。 如何解决：客户端不与系统耦合，外观类与系统耦合。 关键代码：在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。 应用实例： 去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便 JAVA 的三层开发模式 优点： 减少系统相互依赖 提高灵活性 提高了安全性 缺点：不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。 使用场景： 为复杂的模块或子系统提供外界访问的模块 子系统相对独立 预防低水平人员带来的风险 注意事项：在层次化结构中，可以使用外观模式定义系统中每一层的入口。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public interface Facade &#123; void draw();&#125;public class RectangleFacade implements Facade &#123; @Override public void draw() &#123; System.out.println("Rectangle::draw()"); &#125;&#125;public class SquareFacade implements Facade &#123; @Override public void draw() &#123; System.out.println("Square::draw()"); &#125;&#125;public class FacadeMaker &#123; private Facade rectangleFacade; private Facade squareFacade; public FacadeMaker()&#123; rectangleFacade = new RectangleFacade(); squareFacade = new SquareFacade(); &#125; public void drawSquare()&#123; squareFacade.draw(); &#125; public void drawRectangle()&#123; rectangleFacade.draw(); &#125;&#125;public class FacadeTest &#123; public static void main(String[] args) &#123; FacadeMaker facadeMaker = new FacadeMaker(); facadeMaker.drawRectangle(); facadeMaker.drawSquare(); &#125;&#125; 2.7. 享元模式享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。 享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。 意图：运用共享技术有效地支持大量细粒度的对象。 主要解决：在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。 何时使用： 系统中有大量对象 这些对象消耗大量内存 这些对象的状态大部分可以外部化 这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替 系统不依赖于这些对象身份，这些对象是不可分辨的 如何解决：用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。 关键代码：用 HashMap 存储这些对象。 应用实例： JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面 数据库的数据池 优点：大大减少对象的创建，降低系统的内存，使效率提高。 缺点：提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。 使用场景： 系统有大量相似对象 需要缓冲池的场景 注意事项： 注意划分外部状态和内部状态，否则可能会引起线程安全问题 这些类必须有一个工厂对象加以控制 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public interface Flyweight &#123; void draw();&#125;public class CircleFlyweight implements Flyweight &#123; private String color; private int x; private int y; private int radius; public CircleFlyweight(String color)&#123; this.color = color; &#125; public void setX(int x) &#123; this.x = x; &#125; public void setY(int y) &#123; this.y = y; &#125; public void setRadius(int radius) &#123; this.radius = radius; &#125; @Override public void draw() &#123; System.out.println("Circle: Draw() [Color : " + color +", x : " + x +", y :" + y +", radius :" + radius); &#125;&#125;public class FlyweightFactory &#123; private static final HashMap&lt;String, Flyweight&gt; circleMap = new HashMap&lt;&gt;(); public static Flyweight getCircle(String color) &#123; CircleFlyweight circle = (CircleFlyweight) circleMap.get(color); if (circle == null) &#123; circle = new CircleFlyweight(color); circleMap.put(color, circle); System.out.println("Creating circle of color : " + color); &#125; return circle; &#125;&#125;public class FlyweightTest &#123; private static final String colors[] = &#123; "Red", "Green", "Blue", "White", "Black" &#125;; public static void main(String[] args) &#123; for(int i=0; i &lt; 20; ++i) &#123; CircleFlyweight circle = (CircleFlyweight)FlyweightFactory.getCircle(getRandomColor()); circle.setX(getRandomX()); circle.setY(getRandomY()); circle.setRadius(100); circle.draw(); &#125; &#125; private static String getRandomColor() &#123; return colors[(int)(Math.random()*colors.length)]; &#125; private static int getRandomX() &#123; return (int)(Math.random()*100 ); &#125; private static int getRandomY() &#123; return (int)(Math.random()*100); &#125;&#125; 2.8. 代理模式在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。 在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。 意图：为其他对象提供一种代理以控制对这个对象的访问。 主要解决：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。 何时使用：想在访问一个类时做一些控制。 如何解决：增加中间层。 关键代码：实现与被代理类组合。 应用实例： Windows 里面的快捷方式 猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类 买火车票不一定在火车站买，也可以去代售点 一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制 spring aop 优点： 职责清晰 高扩展性 智能化 缺点： 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢 实现代理模式需要额外的工作，有些代理模式的实现非常复杂 使用场景：按职责来划分，通常有以下使用场景： 远程代理 虚拟代理 Copy-on-Write 代理 保护（Protect or Access）代理 Cache代理 防火墙（Firewall）代理 同步化（Synchronization）代理 智能引用（Smart Reference）代理 注意事项： 和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口 和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public interface Image &#123; void display();&#125;public class RealImage implements Image &#123; private String fileName; public RealImage(String fileName) &#123; this.fileName = fileName; loadFromDisk(fileName); &#125; @Override public void display() &#123; System.out.println("Displaying " + fileName); &#125; private void loadFromDisk(String fileName) &#123; System.out.println("Loading " + fileName); &#125;&#125;public class ProxyImage implements Image&#123; private RealImage realImage; private String fileName; public ProxyImage(String fileName)&#123; this.fileName = fileName; &#125; @Override public void display() &#123; if(realImage == null)&#123; realImage = new RealImage(fileName); &#125; realImage.display(); &#125;&#125;public class ProxyTest &#123; public static void main(String[] args) &#123; Image image = new ProxyImage("test_10mb.jpg"); //图像将从磁盘加载 image.display(); System.out.println(""); //图像将无法从磁盘加载 image.display(); &#125;&#125; 3.行为型模式3.1. 责任链模式顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。 在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。 意图：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。 主要解决：职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。 何时使用：在处理消息的时候以过滤很多道。 如何解决：拦截的类都实现统一接口。 关键代码：Handler 里面聚合它自己，在 HanleRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。 应用实例： 红楼梦中的”击鼓传花”。 JS 中的事件冒泡。 AVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。 优点： 降低耦合度。它将请求的发送者和接收者解耦。 简化了对象。使得对象不需要知道链的结构。 增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 增加新的请求处理类很方便。 缺点： 不能保证请求一定被接收。 系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 可能不容易观察运行时的特征，有碍于除错。 使用场景： 有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求 可动态指定一组对象处理请求。 注意事项： 在 JAVA WEB 中遇到很多应用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public abstract class AbstractLogger &#123; public static int INFO = 1; public static int DEBUG = 2; public static int ERROR = 3; protected int level; /** * 责任链中的下一个元素 */ protected AbstractLogger nextLogger; public void setNextLogger(AbstractLogger nextLogger) &#123; this.nextLogger = nextLogger; &#125; public void logMessage(int level, String message) &#123; if (this.level &lt;= level) &#123; write(message); &#125; if (nextLogger != null) &#123; nextLogger.logMessage(level, message); &#125; &#125; abstract protected void write(String message);&#125;public class ConsoleLogger extends AbstractLogger &#123; public ConsoleLogger(int level) &#123; this.level = level; &#125; @Override protected void write(String message) &#123; System.out.println("Standard Console::Logger: " + message); &#125;&#125;public class DebugLogger extends AbstractLogger &#123; public DebugLogger(int level) &#123; this.level = level; &#125; @Override protected void write(String message) &#123; System.out.println("Debug::Logger: " + message); &#125;&#125;public class ErrorLogger extends AbstractLogger &#123; public ErrorLogger(int level) &#123; this.level = level; &#125; @Override protected void write(String message) &#123; System.out.println("Error Console::Logger: " + message); &#125;&#125;public class ChainPatternDemo &#123; private static AbstractLogger getChainOfLoggers() &#123; AbstractLogger errorLogger = new ErrorLogger(AbstractLogger.ERROR); AbstractLogger debugLogger = new DebugLogger(AbstractLogger.DEBUG); AbstractLogger consoleLogger = new ConsoleLogger(AbstractLogger.INFO); errorLogger.setNextLogger(debugLogger); debugLogger.setNextLogger(consoleLogger); return errorLogger; &#125; public static void main(String[] args) &#123; AbstractLogger loggerChain = getChainOfLoggers(); loggerChain.logMessage(AbstractLogger.INFO, "This is an information."); loggerChain.logMessage(AbstractLogger.DEBUG, "This is an debug level information."); loggerChain.logMessage(AbstractLogger.ERROR, "This is an error information."); &#125;&#125; 3.2. 命令模式命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。 意图：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。 主要解决：在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。 何时使用：在某些场合，比如要对行为进行”记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将”行为请求者”与”行为实现者”解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。 如何解决：通过调用者调用接受者执行命令，顺序：调用者→接受者→命令。 关键代码：定义三个角色：1、received 真正的命令执行对象 2、Command 3、invoker 使用命令对象的入口 应用实例：struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command。 优点： 降低了系统耦合度。 新的命令可以很容易添加到系统中去。 缺点：使用命令模式可能会导致某些系统有过多的具体命令类。 使用场景：认为是命令的地方都可以使用命令模式，比如： 1、GUI 中每一个按钮都是一条命令。 2、模拟 CMD。 注意事项：系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public interface Order &#123; void execute();&#125;public class Stock &#123; private String name = "ABC"; private int quantity = 10; public void buy() &#123; System.out.println("Stock [ Name: " + name + ",Quantity:" + quantity + " ]bought "); &#125; public void sell() &#123; System.out.println("Stock [ Name: " + name + ",Quantity:" + quantity + " ]sold "); &#125;&#125;public class BuyStock implements Order &#123; private Stock abcStock; public BuyStock(Stock abcStock)&#123; this.abcStock = abcStock; &#125; @Override public void execute() &#123; abcStock.buy(); &#125;&#125;public class SellStock implements Order &#123; private Stock abcStock; public SellStock(Stock abcStock) &#123; this.abcStock = abcStock; &#125; @Override public void execute() &#123; abcStock.sell(); &#125;&#125;public class Broker &#123; private List&lt;Order&gt; orderList = new ArrayList&lt;&gt;(); public void takeOrder(Order order) &#123; orderList.add(order); &#125; public void placeOrders() &#123; for (Order order : orderList) &#123; order.execute(); &#125; orderList.clear(); &#125;&#125;public class CommandPatternDemo &#123; public static void main(String[] args) &#123; Stock abcStock = new Stock(); BuyStock buyStockOrder = new BuyStock(abcStock); SellStock sellStockOrder = new SellStock(abcStock); Broker broker = new Broker(); broker.takeOrder(buyStockOrder); broker.takeOrder(sellStockOrder); broker.placeOrders(); &#125;&#125; 3.3. 解释器模式解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。 意图：给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。 主要解决：对于一些固定文法构建一个解释句子的解释器。 何时使用：如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。 如何解决：构件语法树，定义终结符与非终结符。 关键代码：构件环境类，包含解释器之外的一些全局信息，一般是 HashMap。 应用实例：编译器、运算表达式计算。 优点： 可扩展性比较好。 增加了新的解释表达式的方式。 易于实现简单文法。 缺点： 可利用场景比较少。 对于复杂的文法比较难维护。 解释器模式会引起类膨胀。 解释器模式采用递归调用方法。 使用场景： 可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。 一些重复出现的问题可以用一种简单的语言来进行表达。 一个简单语法需要解释的场景。 注意事项：可利用场景比较少，JAVA 中如果碰到可以用 expression4J 代替。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public interface Expression &#123; public boolean interpret(String context);&#125;public class TerminalExpression implements Expression &#123; private String data; public TerminalExpression(String data) &#123; this.data = data; &#125; @Override public boolean interpret(String context) &#123; if (context.contains(data)) &#123; return true; &#125; return false; &#125;&#125;public class OrExpression implements Expression &#123; private Expression expr1 = null; private Expression expr2 = null; public OrExpression(Expression expr1, Expression expr2) &#123; this.expr1 = expr1; this.expr2 = expr2; &#125; @Override public boolean interpret(String context) &#123; return expr1.interpret(context) || expr2.interpret(context); &#125;&#125;public class AndExpression implements Expression &#123; private Expression expr1 = null; private Expression expr2 = null; public AndExpression(Expression expr1, Expression expr2) &#123; this.expr1 = expr1; this.expr2 = expr2; &#125; @Override public boolean interpret(String context) &#123; return expr1.interpret(context) &amp;&amp; expr2.interpret(context); &#125;&#125;public class InterpreterPatternDemo &#123; /** * 规则：Robert 和 John 是男性 */ public static Expression getMaleExpression() &#123; Expression robert = new TerminalExpression("Robert"); Expression john = new TerminalExpression("John"); return new OrExpression(robert, john); &#125; /** * 规则：Julie 是一个已婚的女性 */ public static Expression getMarriedWomanExpression() &#123; Expression julie = new TerminalExpression("Julie"); Expression married = new TerminalExpression("Married"); return new AndExpression(julie, married); &#125; public static void main(String[] args) &#123; Expression isMale = getMaleExpression(); Expression isMarriedWoman = getMarriedWomanExpression(); System.out.println("John is male? " + isMale.interpret("John")); System.out.println("Julie is a married women? " + isMarriedWoman.interpret("Married Julie")); &#125;&#125; 3.4. 迭代器模式迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。 迭代器模式属于行为型模式。 意图：提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。 主要解决：不同的方式来遍历整个整合对象。 何时使用：遍历一个聚合对象。 如何解决：把在元素之间游走的责任交给迭代器，而不是聚合对象。 关键代码：定义接口：hasNext, next。 应用实例：JAVA 中的 iterator。 优点： 它支持以不同的方式遍历一个聚合对象。 迭代器简化了聚合类。 在同一个聚合上可以有多个遍历。 在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。 缺点：由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。 使用场景： 访问一个聚合对象的内容而无须暴露它的内部表示。 需要为聚合对象提供多种遍历方式。 为遍历不同的聚合结构提供一个统一的接口。 注意事项：迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public interface Iterator &#123; public boolean hasNext(); public Object next();&#125;public interface Container &#123; public Iterator getIterator();&#125;public class NameRepository implements Container &#123; public String[] names = &#123;"Robert", "John", "Julie", "Lora"&#125;; @Override public Iterator getIterator() &#123; return new NameIterator(); &#125; private class NameIterator implements Iterator &#123; int index; @Override public boolean hasNext() &#123; if (index &lt; names.length) &#123; return true; &#125; return false; &#125; @Override public Object next() &#123; if (this.hasNext()) &#123; return names[index++]; &#125; return null; &#125; &#125;&#125;public class IteratorPatternDemo &#123; public static void main(String[] args) &#123; NameRepository namesRepository = new NameRepository(); for (Iterator iter = namesRepository.getIterator(); iter.hasNext(); ) &#123; String name = (String) iter.next(); System.out.println("Name : " + name); &#125; &#125;&#125; 3.5. 中介者模式中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。 意图：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 主要解决：对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。 何时使用：多个类相互耦合，形成了网状结构。 如何解决：将上述网状结构分离为星型结构。 关键代码：对象 Colleague 之间的通信封装到一个类中单独处理。 应用实例： 中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。 机场调度系统。 MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。 优点： 降低了类的复杂度，将一对多转化成了一对一。 各个类之间的解耦。 符合迪米特原则。 缺点：中介者会庞大，变得复杂难以维护。 使用场景： 系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。 想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。 注意事项：不应当在职责混乱的时候使用。 12345678910111213141516171819202122232425262728293031323334353637public class ChatRoom &#123; public static void showMessage(User user, String message) &#123; System.out.println(new Date().toString() + " [" + user.getName() + "] : " + message); &#125;&#125;public class MediatorPatternDemo &#123; public static void main(String[] args) &#123; User robert = new User("Robert"); User john = new User("John"); robert.sendMessage("Hi! John!"); john.sendMessage("Hello! Robert!"); &#125;&#125;public class User &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public User(String name) &#123; this.name = name; &#125; public void sendMessage(String message) &#123; ChatRoom.showMessage(this, message); &#125;&#125; 3.6. 备忘录模式备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。 意图：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。 主要解决：所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。 何时使用：很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有”后悔药”可吃。 如何解决：通过一个备忘录类专门存储对象状态。 关键代码：客户不与备忘录类耦合，与备忘录管理类耦合。 应用实例： 后悔药。 打游戏时的存档。 Windows 里的 ctri + z。 IE 中的后退。 数据库的事务管理。 优点： 给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 实现了信息的封装，使得用户不需要关心状态的保存细节。 缺点：消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。 使用场景： 需要保存/恢复数据的相关状态场景。 提供一个可回滚的操作。 注意事项： 为了符合迪米特原则，还要增加一个管理备忘录的类。 为了节约内存，可使用原型模式+备忘录模式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class Memento &#123; private String state; public Memento(String state) &#123; this.state = state; &#125; public String getState() &#123; return state; &#125;&#125;public class Originator &#123; private String state; public void setState(String state) &#123; this.state = state; &#125; public String getState() &#123; return state; &#125; public Memento saveStateToMemento() &#123; return new Memento(state); &#125; public void getStateFromMemento(Memento Memento) &#123; state = Memento.getState(); &#125;&#125;public class CareTaker &#123; private List&lt;Memento&gt; mementoList = new ArrayList&lt;Memento&gt;(); public void add(Memento state) &#123; mementoList.add(state); &#125; public Memento get(int index) &#123; return mementoList.get(index); &#125;&#125;public class MementoPatternDemo &#123; public static void main(String[] args) &#123; Originator originator = new Originator(); CareTaker careTaker = new CareTaker(); originator.setState("State #1"); originator.setState("State #2"); careTaker.add(originator.saveStateToMemento()); originator.setState("State #3"); careTaker.add(originator.saveStateToMemento()); originator.setState("State #4"); System.out.println("Current State: " + originator.getState()); originator.getStateFromMemento(careTaker.get(0)); System.out.println("First saved State: " + originator.getState()); originator.getStateFromMemento(careTaker.get(1)); System.out.println("Second saved State: " + originator.getState()); &#125;&#125; 3.7. 观察者模式当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。 意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。 何时使用：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。 如何解决：使用面向对象技术，可以将这种依赖关系弱化。 关键代码：在抽象类里有一个 ArrayList 存放观察者们。 应用实例： 拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。 优点： 观察者和被观察者是抽象耦合的。 建立一套触发机制。 缺点： 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。 使用场景： 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。 一个对象必须通知其他对象，而并不知道这些对象是谁。 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。 注意事项： JAVA 中已经有了对观察者模式的支持类。 避免循环引用。 如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class Subject &#123; private List&lt;Observer&gt; observers = new ArrayList&lt;&gt;(); private int state; public int getState() &#123; return state; &#125; public void setState(int state) &#123; this.state = state; notifyAllObservers(); &#125; public void attach(Observer observer) &#123; observers.add(observer); &#125; public void notifyAllObservers() &#123; for (Observer observer : observers) &#123; observer.update(); &#125; &#125;&#125;public abstract class Observer &#123; protected Subject subject; public abstract void update();&#125;public class BinaryObserver extends Observer &#123; public BinaryObserver(Subject subject) &#123; this.subject = subject; this.subject.attach(this); &#125; @Override public void update() &#123; System.out.println("Binary String: " + Integer.toBinaryString(subject.getState())); &#125;&#125;public class OctalObserver extends Observer &#123; public OctalObserver(Subject subject) &#123; this.subject = subject; this.subject.attach(this); &#125; @Override public void update() &#123; System.out.println("Octal String: " + Integer.toOctalString(subject.getState())); &#125;&#125;public class HexaObserver extends Observer &#123; public HexaObserver(Subject subject) &#123; this.subject = subject; this.subject.attach(this); &#125; @Override public void update() &#123; System.out.println("Hex String: " + Integer.toHexString(subject.getState()).toUpperCase()); &#125;&#125;public class ObserverPatternDemo &#123; public static void main(String[] args) &#123; Subject subject = new Subject(); new HexaObserver(subject); new OctalObserver(subject); new BinaryObserver(subject); System.out.println("First state change: 15"); subject.setState(15); System.out.println("Second state change: 10"); subject.setState(10); &#125;&#125; 3.8. 状态模式在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。 在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。 意图：允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。 主要解决：对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。 何时使用：代码中包含大量与对象状态有关的条件语句。 如何解决：将各种具体的状态类抽象出来。 关键代码：通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if…else 等条件选择语句。 应用实例： 打篮球的时候运动员可以有正常状态、不正常状态和超常状态。 曾侯乙编钟中，’钟是抽象接口’,’钟A’等是具体状态，’曾侯乙编钟’是具体环境（Context）。 优点： 封装了转换规则。 枚举可能的状态，在枚举状态之前需要确定状态种类。 将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。 缺点： 状态模式的使用必然会增加系统类和对象的个数。 态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 状态模式对”开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。 使用场景： 行为随状态改变而改变的场景。 条件、分支语句的代替者。 注意事项：在行为受状态约束的时候使用状态模式，而且状态不超过 5 个。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public interface State &#123; public void doAction(Context context);&#125;public class Context &#123; private State state; public Context() &#123; state = null; &#125; public void setState(State state) &#123; this.state = state; &#125; public State getState() &#123; return state; &#125;&#125;public class StartState implements State &#123; @Override public void doAction(Context context) &#123; System.out.println("Player is in start state"); context.setState(this); &#125; @Override public String toString() &#123; return "Start State"; &#125;&#125;public class StopState implements State &#123; @Override public void doAction(Context context) &#123; System.out.println("Player is in stop state"); context.setState(this); &#125; @Override public String toString() &#123; return "Stop State"; &#125;&#125; 3.9. 空对象模式在空对象模式（Null Object Pattern）中，一个空对象取代 NULL 对象实例的检查。Null 对象不是检查空值，而是反应一个不做任何动作的关系。这样的 Null 对象也可以在数据不可用的时候提供默认的行为。 在空对象模式中，我们创建一个指定各种要执行的操作的抽象类和扩展该类的实体类，还创建一个未对该类做任何实现的空对象类，该空对象类将无缝地使用在需要检查空值的地方。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public abstract class AbstractCustomer &#123; protected String name; public abstract boolean isNil(); public abstract String getName();&#125;public class RealCustomer extends AbstractCustomer &#123; public RealCustomer(String name) &#123; this.name = name; &#125; @Override public String getName() &#123; return name; &#125; @Override public boolean isNil() &#123; return false; &#125;&#125;public class NullCustomer extends AbstractCustomer &#123; @Override public String getName() &#123; return "Not Available in Customer Database"; &#125; @Override public boolean isNil() &#123; return true; &#125;&#125;public class NullPatternDemo &#123; public static void main(String[] args) &#123; AbstractCustomer customer1 = CustomerFactory.getCustomer("Rob"); AbstractCustomer customer2 = CustomerFactory.getCustomer("Bob"); AbstractCustomer customer3 = CustomerFactory.getCustomer("Julie"); AbstractCustomer customer4 = CustomerFactory.getCustomer("Laura"); System.out.println("Customers"); System.out.println(customer1.getName()); System.out.println(customer2.getName()); System.out.println(customer3.getName()); System.out.println(customer4.getName()); &#125;&#125;public class CustomerFactory &#123; public static final String[] names = &#123;"Rob", "Joe", "Julie"&#125;; public static AbstractCustomer getCustomer(String name) &#123; for (int i = 0; i &lt; names.length; i++) &#123; if (names[i].equalsIgnoreCase(name)) &#123; return new RealCustomer(name); &#125; &#125; return new NullCustomer(); &#125;&#125; 3.10. 策略模式在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。 在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。 意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。 主要解决：在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。 何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。 如何解决：将这些算法封装成一个一个的类，任意地替换。 关键代码：实现同一个接口。 应用实例： 诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 JAVA AWT 中的 LayoutManager。 优点： 算法可以自由切换。 避免使用多重条件判断。 扩展性良好。 缺点： 策略类会增多。 所有策略类都需要对外暴露。 使用场景： 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。 注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public interface Strategy &#123; public int doOperation(int num1, int num2);&#125;public class OperationAdd implements Strategy&#123; @Override public int doOperation(int num1, int num2) &#123; return num1 + num2; &#125;&#125;public class OperationSubstract implements Strategy&#123; @Override public int doOperation(int num1, int num2) &#123; return num1 - num2; &#125;&#125;public class OperationMultiply implements Strategy&#123; @Override public int doOperation(int num1, int num2) &#123; return num1 * num2; &#125;&#125;public class Context &#123; private State state; public Context() &#123; state = null; &#125; public void setState(State state) &#123; this.state = state; &#125; public State getState() &#123; return state; &#125; private Strategy strategy; public Context(Strategy strategy)&#123; this.strategy = strategy; &#125; public int executeStrategy(int num1, int num2)&#123; return strategy.doOperation(num1, num2); &#125;&#125;public class StrategyPatternDemo &#123; public static void main(String[] args) &#123; Context context = new Context(new OperationAdd()); System.out.println("10 + 5 = " + context.executeStrategy(10, 5)); context = new Context(new OperationSubstract()); System.out.println("10 - 5 = " + context.executeStrategy(10, 5)); context = new Context(new OperationMultiply()); System.out.println("10 * 5 = " + context.executeStrategy(10, 5)); &#125;&#125; 3.11. 模板模式在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。 意图：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 主要解决：一些方法通用，却在每一个子类都重新写了这一方法。 何时使用：有一些通用的方法。 如何解决：将这些通用算法抽象出来。 关键代码：在抽象类实现，其他步骤在子类实现。 应用实例： 在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。 优点： 封装不变部分，扩展可变部分。 提取公共代码，便于维护。 行为由父类控制，子类实现。 缺点：每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。 使用场景： 有多个子类共有的方法，且逻辑相同。 重要的、复杂的方法，可以考虑作为模板方法。 注意事项：为防止恶意操作，一般模板方法都加上 final 关键词。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public abstract class Game &#123; abstract void initialize(); abstract void startPlay(); abstract void endPlay(); /** * 模板 */ public final void play() &#123; //初始化游戏 initialize(); //开始游戏 startPlay(); //结束游戏 endPlay(); &#125;&#125;public class Cricket extends Game &#123; @Override void endPlay() &#123; System.out.println("Cricket Game Finished!"); &#125; @Override void initialize() &#123; System.out.println("Cricket Game Initialized! Start playing."); &#125; @Override void startPlay() &#123; System.out.println("Cricket Game Started. Enjoy the game!"); &#125;&#125;public class Football extends Game &#123; @Override void endPlay() &#123; System.out.println("Football Game Finished!"); &#125; @Override void initialize() &#123; System.out.println("Football Game Initialized! Start playing."); &#125; @Override void startPlay() &#123; System.out.println("Football Game Started. Enjoy the game!"); &#125;&#125;public class TemplatePatternDemo &#123; public static void main(String[] args) &#123; Game game = new Cricket(); game.play(); System.out.println(); game = new Football(); game.play(); &#125;&#125; 3.12. 访问者模式在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。 意图：主要将数据结构与数据操作分离。 主要解决：稳定的数据结构和易变的操作耦合问题。 何时使用：需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，使用访问者模式将这些封装到类中。 如何解决：在被访问的类里面加一个对外提供接待访问者的接口。 关键代码：在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。 应用实例：您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。 优点： 符合单一职责原则。 优秀的扩展性。 灵活性。 缺点： 具体元素对访问者公布细节，违反了迪米特原则。 具体元素变更比较困难。 违反了依赖倒置原则，依赖了具体类，没有依赖抽象。 使用场景： 对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类。 注意事项：访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public interface ComputerPart &#123; public void accept(ComputerPartVisitor computerPartVisitor);&#125;public interface ComputerPartVisitor &#123; public void visit(Computer computer); public void visit(Mouse mouse); public void visit(Keyboard keyboard); public void visit(Monitor monitor);&#125;public class Keyboard implements ComputerPart &#123; @Override public void accept(ComputerPartVisitor computerPartVisitor) &#123; computerPartVisitor.visit(this); &#125;&#125;public class Monitor implements ComputerPart &#123; @Override public void accept(ComputerPartVisitor computerPartVisitor) &#123; computerPartVisitor.visit(this); &#125;&#125;public class Mouse implements ComputerPart &#123; @Override public void accept(ComputerPartVisitor computerPartVisitor) &#123; computerPartVisitor.visit(this); &#125;&#125;public class Computer implements ComputerPart &#123; ComputerPart[] parts; public Computer() &#123; parts = new ComputerPart[]&#123;new Mouse(), new Keyboard(), new Monitor()&#125;; &#125; @Override public void accept(ComputerPartVisitor computerPartVisitor) &#123; for (int i = 0; i &lt; parts.length; i++) &#123; parts[i].accept(computerPartVisitor); &#125; computerPartVisitor.visit(this); &#125;&#125;public class ComputerPartDisplayVisitor implements ComputerPartVisitor &#123; @Override public void visit(Computer computer) &#123; System.out.println("Displaying Computer."); &#125; @Override public void visit(Mouse mouse) &#123; System.out.println("Displaying Mouse."); &#125; @Override public void visit(Keyboard keyboard) &#123; System.out.println("Displaying Keyboard."); &#125; @Override public void visit(Monitor monitor) &#123; System.out.println("Displaying Monitor."); &#125;&#125;public class VisitorPatternDemo &#123; public static void main(String[] args) &#123; ComputerPart computer = new Computer(); computer.accept(new ComputerPartDisplayVisitor()); &#125;&#125;]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习]]></title>
    <url>%2F2017%2F10%2F09%2FGit%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Git中文文档 Git 起步1.Git历史同生活中的许多伟大事物一样，Git 诞生于一个极富纷争大举创新的年代。Linux 内核开源项目有着为数众广的参与者。 绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。 到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。 到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。 他们对新的系统制订了若干目标： 速度 简单的设计 对非线性开发模式的强力支持（允许成千上万个并行开发的分支） 完全分布式 有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量） 自诞生于 2005 年以来，Git 日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标。 它的速度飞快，极其适合管理大项目，有着令人难以置信的非线性分支管理系统。 2.Git机制2.1. Git 保证完整性Git 中所有数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。 这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。 若你在传送过程中丢失信息或损坏文件，Git 就能发现。 Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来。 SHA-1 哈希看起来是这样： 24b9da6552252987aa493b52f8696cd6d3b00373 Git 中使用这种哈希值的情况很多，你将经常看到这种哈希值。 实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。 2.2. 三种状态 Git 有三种状态，你的文件可能处于其中之一：已提交（committed）、已修改（modified）和已暂存（staged）。 已提交表示数据已经安全的保存在本地数据库中。 已修改表示修改了文件，但还没保存到数据库中。 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。 由此引入 Git 项目的三个工作区域的概念：Git 仓库、工作目录 以及暂存区域。 2.3. Git 仓库、工作目录 、暂存区域 Git 仓库目录 是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。 工作目录 是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。 暂存区域 是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 有时候也被称作`‘索引’’，不过一般说法还是叫暂存区域。 基本的 Git 工作流程如下： 在工作目录中修改文件。 暂存文件，将文件的快照放入暂存区域。 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。 如果 Git 目录中保存着的特定版本文件，就属于已提交状态。 如果作了修改并已放入暂存区域，就属于已暂存状态。 如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态。 3.初次运行 Git 前的配置Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置： /etc/gitconfig 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果使用带有 --system 选项的 git config 时，它会从此文件读写配置变量。 ~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。 可以传递 --global 选项让 Git 读写此文件。 当前使用仓库的 Git 目录中的 config 文件（就是 .git/config）：针对该仓库。 每一个级别覆盖上一级别的配置，所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量。 在 Windows 系统中，Git 会查找 $HOME 目录下（一般情况下是 C:\Users\$USER）的 .gitconfig 文件。 Git 同样也会寻找 /etc/gitconfig 文件，但只限于 MSys 的根目录下，即安装 Git 时所选的目标位置。 3.1. 用户配置当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址。 这样做很重要，因为每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改： $ git config --global user.name &quot;John Doe&quot; $ git config –global user.email johndoe@example.com 再次强调，如果使用了 --global 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 --global 选项的命令来配置。 很多 GUI 工具都会在第一次运行时帮助你配置这些信息。 3.2. 文本编辑器既然用户信息已经设置完毕，你可以配置默认文本编辑器了，当 Git 需要你输入信息时会调用它。 如果未配置，Git 会使用操作系统默认的文本编辑器，通常是 Vim。 如果你想使用不同的文本编辑器，例如 Emacs，可以这样做： $ git config --global core.editor emacs Warning Vim 和 Emacs 是像 Linux 与 Mac 等基于 Unix 的系统上开发者经常使用的流行的文本编辑器。 如果你对这些编辑器都不是很了解或者你使用的是 Windows 系统，那么可能需要搜索如何在 Git 中配置你最常用的编辑器。 如果你不设置编辑器并且不知道 Vim 或 Emacs 是什么，当它们运行起来后你可能会被弄糊涂、不知所措。 3.3. 检查配置信息如果想要检查你的配置，可以使用 git config --list 命令来列出所有 Git 当时能找到的配置。 $ git config --list user.name=John Doe user.email=johndoe@example.com color.status=auto color.branch=auto color.interactive=auto color.diff=auto ... 你可能会看到重复的变量名，因为 Git 会从不同的文件中读取同一个配置（例如：/etc/gitconfig 与 ~/.gitconfig）。 这种情况下，Git 会使用它找到的每一个变量的最后一个配置。 你可以通过输入 git config &lt;key&gt;： 来检查 Git 的某一项配置 $ git config user.name John Doe Git 基础1.获取 Git 仓库在现有目录中初始化仓库如果你打算使用 Git 来对现有的项目进行管理，你只需要进入该项目目录并输入： $ git init $ git add *.c $ git add LICENSE$ git commit -m ‘initial project version’ 2.克隆现有的仓库$ git clone https://github.com/libgit2/libgit2 $ git clone https://github.com/libgit2/libgit2 mylibgit 这将执行与上一个命令相同的操作，不过在本地创建的仓库名字变为 mylibgit。 3.记录每次更新到仓库 2.1. 检查当前文件状态$ git status On branch master nothing to commit, working directory clean 现在，让我们在项目下创建一个新的 README 文件。 如果之前并不存在这个文件，使用 git status 命令，你将看到一个新的未跟踪文件： $ echo &apos;My Project&apos; &gt; README $ git status On branch master Untracked files: (use “git add …” to include in what will be committed) README nothing added to commit but untracked files present (use &quot;git add&quot; to track) 在状态报告中可以看到新建的 README 文件出现在 Untracked files 下面。 未跟踪的文件意味着 Git 在之前的快照（提交）中没有这些文件；Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”， 这样的处理让你不必担心将生成的二进制文件或其它不想被跟踪的文件包含进来。 不过现在的例子中，我们确实想要跟踪管理 README 这个文件。 2.2. 跟踪新文件使用命令 git add 开始跟踪一个文件。 所以，要跟踪 README 文件，运行： $ git add README 此时再运行 git status 命令，会看到 README 文件已被跟踪，并处于暂存状态： $ git status On branch master Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: README 只要在 Changes to be committed 这行下面的，就说明是已暂存状态。 如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。 你可能会想起之前我们使用 git init 后就运行了 git add (files) 命令，开始跟踪当前目录下的文件。 git add 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。 2.3. 暂存已修改文件现在我们来修改一个已被跟踪的文件。 如果你修改了一个名为 CONTRIBUTING.md 的已被跟踪的文件，然后运行 git status 命令，会看到下面内容： $ git status On branch master Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: README Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: CONTRIBUTING.md 文件 CONTRIBUTING.md 出现在 Changes not staged for commit 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。 要暂存这次更新，需要运行 git add 命令。 这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。 现在让我们运行 git add 将”CONTRIBUTING.md“放到暂存区，然后再看看 git status 的输出： $ git add CONTRIBUTING.md $ git status On branch master Changes to be committed: (use “git reset HEAD …” to unstage) new file: README modified: CONTRIBUTING.md 现在两个文件都已暂存，下次提交时就会一并记录到仓库。 假设此时，你想要在 CONTRIBUTING.md 里再加条注释， 重新编辑存盘后，准备好提交。 不过且慢，再运行 git status 看看： $ vim CONTRIBUTING.md $ git status On branch master Changes to be committed: (use “git reset HEAD …” to unstage) new file: README modified: CONTRIBUTING.md Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: CONTRIBUTING.md 怎么回事？ 现在 CONTRIBUTING.md 文件同时出现在暂存区和非暂存区。 这怎么可能呢？ 好吧，实际上 Git 只不过暂存了你运行 git add 命令时的版本， 如果你现在提交，CONTRIBUTING.md 的版本是你最后一次运行 git add 命令时的那个版本，而不是你运行 git commit 时，在工作目录中的当前版本。 所以，运行了 git add 之后又作了修订的文件，需要重新运行 git add 把最新版本重新暂存起来： $ git add CONTRIBUTING.md $ git status On branch master Changes to be committed: (use “git reset HEAD …” to unstage) new file: README modified: CONTRIBUTING.md 2.4. 状态简览git status 命令的输出十分详细，但其用语有些繁琐。 如果你使用 git status -s 命令或 git status --short 命令，你将得到一种更为紧凑的格式输出。 运行 git status -s ，状态报告输出如下： $ git status -s M README MM Rakefile A lib/git.rb M lib/simplegit.rb ?? LICENSE.txt 新添加的未跟踪文件前面有 ?? 标记，新添加到暂存区中的文件前面有 A 标记，修改过的文件前面有 M 标记。 你可能注意到了 M 有两个可以出现的位置，出现在右边的 M 表示该文件被修改了但是还没放入暂存区，出现在靠左边的 M 表示该文件被修改了并放入了暂存区。 例如，上面的状态报告显示： README 文件在工作区被修改了但是还没有将修改后的文件放入暂存区,lib/simplegit.rb 文件被修改了并将修改后的文件放入了暂存区。 而 Rakefile 在工作区被修改并提交到暂存区后又在工作区中被修改了，所以在暂存区和工作区都有该文件被修改了的记录。 2.5. 忽略文件一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式。 来看一个实际的例子： $ cat .gitignore *.[oa] *~ 第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。 第二行告诉 Git 忽略所有以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。 此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。 要养成一开始就设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。 文件 .gitignore 的格式规范如下： 列表项 所有空行或者以 ＃ 开头的行都会被 Git 忽略。 可以使用标准的 glob 模式匹配。 匹配模式可以以（/）开头防止递归。 匹配模式可以以（/）结尾指定目录。 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。 所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（*）匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。 使用两个星号（*) 表示匹配任意中间目录，比如a/**/z 可以匹配 a/z, a/b/z 或 a/b/c/z等。 2.6. 查看已暂存和未暂存的修改如果 git status 命令的输出对于你来说过于模糊，你想知道具体修改了什么地方，可以用 git diff 命令。git diff 将通过文件补丁的格式显示具体哪些行发生了改变。 假如再次修改 README 文件后暂存，然后编辑 CONTRIBUTING.md 文件后先不暂存， 运行 status 命令将会看到： $ git status On branch master Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: README Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: CONTRIBUTING.md 要查看尚未暂存的文件更新了哪些部分，不加参数直接输入 git diff： $ git diff diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md index 8ebb991..643e24f 100644 --- a/CONTRIBUTING.md +++ b/CONTRIBUTING.md @@ -65,7 +65,8 @@ branch directly, things can get messy. Please include a nice description of your changes when you submit your PR; if we have to read the whole diff to figure out why you&apos;re contributing in the first place, you&apos;re less likely to get feedback and have your change -merged in. +merged in. Also, split your changes into comprehensive chunks if your patch is +longer than a dozen lines. If you are starting to work on a particular area, feel free to submit a PR that highlights your work in progress (and note in the PR title that it&apos;s 此命令比较的是工作目录中当前文件和暂存区域快照之间的差异， 也就是修改之后还没有暂存起来的变化内容。 若要查看已暂存的将要添加到下次提交里的内容，可以用 git diff --cached 命令。（Git 1.6.1 及更高版本还允许使用 git diff --staged，效果是相同的，但更好记些。） $ git diff --staged diff --git a/README b/README new file mode 100644 index 0000000..03902a1 --- /dev/null +++ b/README @@ -0,0 +1 @@ +My Project 请注意，git diff 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。 所以有时候你一下子暂存了所有更新过的文件后，运行 git diff 后却什么也没有，就是这个原因。 像之前说的，暂存 CONTRIBUTING.md 后再编辑，运行 git status 会看到暂存前后的两个版本。 如果我们的环境（终端输出）看起来如下： $ git add CONTRIBUTING.md $ echo ‘# test line’ &gt;&gt; CONTRIBUTING.md $ git status On branch master Changes to be committed: (use “git reset HEAD …” to unstage) modified: CONTRIBUTING.md Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: CONTRIBUTING.md 现在运行 git diff 看暂存前后的变化： $ git diff diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md index 643e24f..87f08c8 100644 --- a/CONTRIBUTING.md +++ b/CONTRIBUTING.md @@ -119,3 +119,4 @@ at the ## Starter Projects See our [projects list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md). +# test line 然后用 git diff --cached 查看已经暂存起来的变化：（--staged 和 --cached 是同义词） $ git diff --cached diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md index 8ebb991..643e24f 100644 --- a/CONTRIBUTING.md +++ b/CONTRIBUTING.md @@ -65,7 +65,8 @@ branch directly, things can get messy. Please include a nice description of your changes when you submit your PR; if we have to read the whole diff to figure out why you&apos;re contributing in the first place, you&apos;re less likely to get feedback and have your change -merged in. +merged in. Also, split your changes into comprehensive chunks if your patch is +longer than a dozen lines. If you are starting to work on a particular area, feel free to submit a PR that highlights your work in progress (and note in the PR title that it&apos;s Note Git Diff 的插件版本在本书中，我们使用 git diff 来分析文件差异。 但是，如果你喜欢通过图形化的方式或其它格式输出方式的话，可以使用 git difftool 命令来用 Araxis ，emerge 或 vimdiff 等软件输出 diff 分析结果。 使用 git difftool --tool-help 命令来看你的系统支持哪些 Git Diff 插件。 2.7. 提交更新现在的暂存区域已经准备妥当可以提交了。 在此之前，请一定要确认还有什么修改过的或新建的文件还没有 git add 过，否则提交的时候不会记录这些还没暂存起来的变化。 这些修改过的文件只保留在本地磁盘。 所以，每次准备提交前，先用 git status 看下，是不是都已暂存起来了， 然后再运行提交命令 git commit： $ git commit 这种方式会启动文本编辑器以便输入本次提交的说明。 (默认会启用 shell 的环境变量 $EDITOR 所指定的软件，一般都是 vim 或 emacs。当然也可以按照 起步 介绍的方式，使用 git config --global core.editor 命令设定你喜欢的编辑软件。） 编辑器会显示类似下面的文本信息（本例选用 Vim 的屏显方式展示）： # Please enter the commit message for your changes. Lines starting # with &apos;#&apos; will be ignored, and an empty message aborts the commit. # On branch master # Changes to be committed: # new file: README # modified: CONTRIBUTING.md # ~ ~ ~ &quot;.git/COMMIT_EDITMSG&quot; 9L, 283C 可以看到，默认的提交消息包含最后一次运行 git status 的输出，放在注释行里，另外开头还有一空行，供你输入提交说明。 你完全可以去掉这些注释行，不过留着也没关系，多少能帮你回想起这次更新的内容有哪些。 (如果想要更详细的对修改了哪些内容的提示，可以用 -v 选项，这会将你所做的改变的 diff 输出放到编辑器中从而使你知道本次提交具体做了哪些修改。） 退出编辑器时，Git 会丢掉注释行，用你输入提交附带信息生成一次提交。 另外，你也可以在 commit 命令后添加 -m 选项，将提交信息与命令放在同一行，如下所示： $ git commit -m &quot;Story 182: Fix benchmarks for speed&quot; [master 463dc4f] Story 182: Fix benchmarks for speed 2 files changed, 2 insertions(+) create mode 100644 README 好，现在你已经创建了第一个提交！ 可以看到，提交后它会告诉你，当前是在哪个分支（master）提交的，本次提交的完整 SHA-1 校验和是什么（463dc4f），以及在本次提交中，有多少文件修订过，多少行添加和删改过。 请记住，提交时记录的是放在暂存区域的快照。 任何还未暂存的仍然保持已修改状态，可以在下次提交时纳入版本管理。 每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。 2.8. 跳过使用暂存区域尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。 Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤： $ git status On branch master Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: CONTRIBUTING.md no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) $ git commit -a -m &apos;added new benchmarks&apos; [master 83e38c7] added new benchmarks 1 file changed, 5 insertions(+), 0 deletions(-) 2.9. 移除文件要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 可以用 git rm 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。 如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 “Changes not staged for commit” 部分（也就是 未暂存清单）看到： $ rm PROJECTS.md $ git status On branch master Your branch is up-to-date with ‘origin/master’. Changes not staged for commit: (use “git add/rm …” to update what will be committed) (use “git checkout – …” to discard changes in working directory) deleted: PROJECTS.md no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 然后再运行 git rm 记录此次移除文件的操作： $ git rm PROJECTS.md rm ‘PROJECTS.md’$ git status On branch master Changes to be committed: (use “git reset HEAD …” to unstage) deleted: PROJECTS.md 下一次提交时，该文件就不再纳入版本管理了。 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被 Git 恢复。 另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。 换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 当你忘记添加 .gitignore 文件，不小心把一个很大的日志文件或一堆 .a 这样的编译生成文件添加到暂存区时，这一做法尤其有用。 为达到这一目的，使用 --cached 选项： $ git rm --cached README git rm 命令后面可以列出文件或者目录的名字，也可以使用 glob 模式。 比方说： $ git rm log/\*.log 注意到星号 * 之前的反斜杠 \， 因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用 shell 来帮忙展开。 此命令删除 log/ 目录下扩展名为 .log 的所有文件。 类似的比如： $ git rm \*~ 该命令为删除以 ~ 结尾的所有文件。 2.10. 移动文件不像其它的 VCS 系统，Git 并不显式跟踪文件移动操作。 如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。 不过 Git 非常聪明，它会推断出究竟发生了什么，至于具体是如何做到的，我们稍后再谈。 既然如此，当你看到 Git 的 mv 命令时一定会困惑不已。 要在 Git 中对文件改名，可以这么做： $ git mv file_from file_to 它会恰如预期般正常工作。 实际上，即便此时查看状态信息，也会明白无误地看到关于重命名操作的说明： $ git mv README.md README $ git status On branch master Changes to be committed: (use “git reset HEAD …” to unstage) renamed: README.md -&gt; README 其实，运行 git mv 就相当于运行了下面三条命令： $ mv README.md README $ git rm README.md $ git add README 如此分开操作，Git 也会意识到这是一次改名，所以不管何种方式结果都一样。 两者唯一的区别是，mv 是一条命令而另一种方式需要三条命令，直接用 git mv 轻便得多。 不过有时候用其他工具批处理改名的话，要记得在提交前删除老的文件名，再添加新的文件名。 3.查看提交历史3.1. 查看提交历史在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 git log 命令。 接下来的例子会用我专门用于演示的 simplegit 项目， 运行下面的命令获取该项目源代码： git clone https://github.com/schacon/simplegit-progit 然后在此项目中运行 git log，应该会看到下面的输出： $ git log commit ca82a6dff817ec66f44342007202690a93763949 Author: Scott Chacon &lt;schacon@gee-mail.com&gt; Date: Mon Mar 17 21:52:11 2008 -0700 changed the version number commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 Author: Scott Chacon &lt;schacon@gee-mail.com&gt; Date: Sat Mar 15 16:40:33 2008 -0700 removed unnecessary test commit a11bef06a3f659402fe7563abf99ad00de2209e6 Author: Scott Chacon &lt;schacon@gee-mail.com&gt; Date: Sat Mar 15 10:31:28 2008 -0700 first commit 默认不用任何参数的话，git log 会按提交时间列出所有的更新，最近的更新排在最上面。 正如你所看到的，这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。 git log 有许多选项可以帮助你搜寻你所要找的提交， 接下来我们介绍些最常用的。 一个常用的选项是 -p，用来显示每次提交的内容差异。 你也可以加上 -2 来仅显示最近两次提交： $ git log -p -2 commit ca82a6dff817ec66f44342007202690a93763949 Author: Scott Chacon &lt;schacon@gee-mail.com&gt; Date: Mon Mar 17 21:52:11 2008 -0700 changed the version number diff --git a/Rakefile b/Rakefile index a874b73..8f94139 100644 --- a/Rakefile +++ b/Rakefile @@ -5,7 +5,7 @@ require &apos;rake/gempackagetask&apos; spec = Gem::Specification.new do |s| s.platform = Gem::Platform::RUBY s.name = &quot;simplegit&quot; - s.version = &quot;0.1.0&quot; + s.version = &quot;0.1.1&quot; s.author = &quot;Scott Chacon&quot; s.email = &quot;schacon@gee-mail.com&quot; s.summary = &quot;A simple gem for using Git in Ruby code.&quot; commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 Author: Scott Chacon &lt;schacon@gee-mail.com&gt; Date: Sat Mar 15 16:40:33 2008 -0700 removed unnecessary test diff --git a/lib/simplegit.rb b/lib/simplegit.rb index a0a60ae..47c6340 100644 --- a/lib/simplegit.rb +++ b/lib/simplegit.rb @@ -18,8 +18,3 @@ class SimpleGit end end - -if $0 == __FILE__ - git = SimpleGit.new - puts git.show -end \ No newline at end of file 该选项除了显示基本信息之外，还附带了每次 commit 的变化。 当进行代码审查，或者快速浏览某个搭档提交的 commit 所带来的变化的时候，这个参数就非常有用了。 你也可以为 git log 附带一系列的总结性选项。 比如说，如果你想看到每次提交的简略的统计信息，你可以使用 –stat 选项： $ git log --stat commit ca82a6dff817ec66f44342007202690a93763949 Author: Scott Chacon &lt;schacon@gee-mail.com&gt; Date: Mon Mar 17 21:52:11 2008 -0700 changed the version number Rakefile | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 Author: Scott Chacon &lt;schacon@gee-mail.com&gt; Date: Sat Mar 15 16:40:33 2008 -0700 removed unnecessary test lib/simplegit.rb | 5 ----- 1 file changed, 5 deletions(-) commit a11bef06a3f659402fe7563abf99ad00de2209e6 Author: Scott Chacon &lt;schacon@gee-mail.com&gt; Date: Sat Mar 15 10:31:28 2008 -0700 first commit README | 6 ++++++ Rakefile | 23 +++++++++++++++++++++++ lib/simplegit.rb | 25 +++++++++++++++++++++++++ 3 files changed, 54 insertions(+) 正如你所看到的，--stat 选项在每次提交的下面列出所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。 在每次提交的最后还有一个总结。 另外一个常用的选项是 --pretty。 这个选项可以指定使用不同于默认格式的方式展示提交历史。 这个选项有一些内建的子选项供你使用。 比如用 oneline 将每个提交放在一行显示，查看的提交数很大时非常有用。 另外还有 short，full 和 fuller 可以用，展示的信息或多或少有些不同，请自己动手实践一下看看效果如何。 $ git log --pretty=oneline ca82a6dff817ec66f44342007202690a93763949 changed the version number 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test a11bef06a3f659402fe7563abf99ad00de2209e6 first commit 但最有意思的是 format，可以定制要显示的记录格式。 这样的输出对后期提取分析格外有用 — 因为你知道输出的格式不会随着 Git 的更新而发生改变： $ git log --pretty=format:&quot;%h - %an, %ar : %s&quot; ca82a6d - Scott Chacon, 6 years ago : changed the version number 085bb3b - Scott Chacon, 6 years ago : removed unnecessary test a11bef0 - Scott Chacon, 6 years ago : first commit git log --pretty=format 常用的选项 列出了常用的格式占位符写法及其代表的意义。 git log --pretty=format 常用的选项： |—————–+————|| 选项 | 说明 ||—————–|:———–|| %H | 提交对象（commit）的完整哈希字串 || %h | 提交对象的简短哈希字串 || %T | 树对象（tree）的完整哈希字串 || %t | 树对象的简短哈希字串 || %P | 父对象（parent）的完整哈希字串 || %p | 父对象的简短哈希字串 || %an | 作者（author）的名字|| %ae | 作者的电子邮件地址 || %ad | 作者修订日期（可以用 –date= 选项定制格式） || %ar | 作者修订日期，按多久以前的方式显示 || %cn | 提交者（committer）的名字 || %ce | 提交者的电子邮件地址 || %cd | 提交日期 || %cr | 提交日期，按多久以前的方式显示 || %s | 提交说明 ||—————–+————| 你一定奇怪 作者 和 提交者 之间究竟有何差别， 其实作者指的是实际作出修改的人，提交者指的是最后将此工作成果提交到仓库的人。 所以，当你为某个项目发布补丁，然后某个核心成员将你的补丁并入项目时，你就是作者，而那个核心成员就是提交者。 我们会在 分布式 Git 再详细介绍两者之间的细微差别。 当 oneline 或 format 与另一个 log 选项 --graph 结合使用时尤其有用。 这个选项添加了一些ASCII字符串来形象地展示你的分支、合并历史： $ git log --pretty=format:&quot;%h %s&quot; --graph * 2d3acf9 ignore errors from SIGCHLD on trap * 5e3ee11 Merge branch &apos;master&apos; of git://github.com/dustin/grit |\ | * 420eac9 Added a method for getting the current branch. * | 30e367c timeout code and tests * | 5a09431 add timeout protection to grit * | e1193f8 support for heads with slashes in them |/ * d6016bc require time for xmlschema * 11d191e Merge branch &apos;defunkt&apos; into local 以上只是简单介绍了一些 git log 命令支持的选项。 git log 的常用选项 列出了我们目前涉及到的和没涉及到的选项，以及它们是如何影响 log 命令的输出的：git log 的常用选项： |—————–+————|| 选项 | 说明 ||—————–|:———–|| -p | 按补丁格式显示每个更新之间的差异 || –stat | 显示每次更新的文件修改统计信息 || –shortstat | 只显示 –stat 中最后的行数修改添加移除统计 || –name-only | 仅在提交信息后显示已修改的文件清单 || –name-status | 显示新增、修改、删除的文件清单 || –abbrev-commit | 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符 || –relative-date | 使用较短的相对时间显示（比如，“2 weeks ago”）|| –graph | 显示 ASCII 图形表示的分支合并历史 || –pretty | 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）） ||—————–+————| 3.2. 限制输出长度除了定制输出格式的选项之外，git log 还有许多非常实用的限制输出长度的选项，也就是只输出部分提交信息。 之前你已经看到过 -2 了，它只显示最近的两条提交， 实际上，这是 -&lt;n&gt; 选项的写法，其中的 n 可以是任何整数，表示仅显示最近的若干条提交。 不过实践中我们是不太用这个选项的，Git 在输出所有提交时会自动调用分页程序，所以你一次只会看到一页的内容。 另外还有按照时间作限制的选项，比如 --since 和 --until 也很有用。 例如，下面的命令列出所有最近两周内的提交： $ git log --since=2.weeks 这个命令可以在多种格式下工作，比如说具体的某一天 “2008-01-15”，或者是相对地多久以前 “2 years 1 day 3 minutes ago”。 还可以给出若干搜索条件，列出符合的提交。 用 --author 选项显示指定作者的提交，用 --grep 选项搜索提交说明中的关键字。 （请注意，如果要得到同时满足这两个选项搜索条件的提交，就必须用 --all-match 选项。否则，满足任意一个条件的提交都会被匹配出来） 另一个非常有用的筛选选项是 -S，可以列出那些添加或移除了某些字符串的提交。 比如说，你想找出添加或移除了某一个特定函数的引用的提交，你可以这样使用： $ git log -Sfunction_name 最后一个很实用的 git log 选项是路径（path）， 如果只关心某些文件或者目录的历史提交，可以在 git log 选项的最后指定它们的路径。 因为是放在最后位置上的选项，所以用两个短划线（--）隔开之前的选项和后面限定的路径名。 在 限制 git log 输出的选项 中列出了常用的选项： |—————–+————|| 选项 | 说明 ||—————–|:———–|| -(n) | 仅显示最近的 n 条提交 || –since, –after | 仅显示指定时间之后的提交 || –until, –before | 仅显示指定时间之前的提交 || –author | 仅显示指定作者相关的提交 || –committer | 仅显示指定提交者相关的提交 || –grep | 仅显示含指定关键字的提交 || -S | 仅显示添加或移除了某个关键字的提交 ||—————–+————| 来看一个实际的例子，如果要查看 Git 仓库中，2008 年 10 月期间，Junio Hamano 提交的但未合并的测试文件，可以用下面的查询命令： $ git log --pretty=&quot;%h - %s&quot; --author=gitster --since=&quot;2008-10-01&quot; \ --before=&quot;2008-11-01&quot; --no-merges -- t/ 5610e3b - Fix testcase failure when extended attributes are in use acd3b9e - Enhance hold_lock_file_for_{update,append}() API f563754 - demonstrate breakage of detached checkout with symbolic link HEAD d1a43f2 - reset --hard/read-tree --reset -u: remove unmerged new paths 51a94af - Fix &quot;checkout --track -b newbranch&quot; on detached HEAD b0ad11e - pull: allow &quot;git pull origin $something:$current_branch&quot; into an unborn branch 在近 40000 条提交中，上面的输出仅列出了符合条件的 6 条记录。 4.撤消操作4.1. 撤消操作在任何一个阶段，你都有可能想要撤消某些操作。 这里，我们将会学习几个撤消你所做修改的基本工具。 注意，有些撤消操作是不可逆的。 这是在使用 Git 的过程中，会因为操作失误而导致之前的工作丢失的少有的几个地方之一。 有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 --amend 选项的提交命令尝试重新提交： $ git commit --amend 这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。 文本编辑器启动后，可以看到之前的提交信息。 编辑后保存会覆盖原来的提交信息。 例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作： $ git commit -m &apos;initial commit&apos; $ git add forgotten_file $ git commit –amend 最终你只会有一个提交 - 第二次提交将代替第一次提交的结果。 取消暂存的文件接下来的两个小节演示如何操作暂存区域与工作目录中已修改的文件。 这些命令在修改文件状态的同时，也会提示如何撤消操作。 例如，你已经修改了两个文件并且想要将它们作为两次独立的修改提交，但是却意外地输入了 git add * 暂存了它们两个。 如何只取消暂存两个中的一个呢？ git status 命令提示了你： $ git add * $ git status On branch master Changes to be committed: (use “git reset HEAD …” to unstage) renamed: README.md -&gt; README modified: CONTRIBUTING.md 在 “Changes to be committed” 文字正下方，提示使用 git reset HEAD &lt;file&gt;... 来取消暂存。 所以，我们可以这样来取消暂存 CONTRIBUTING.md 文件： $ git reset HEAD CONTRIBUTING.md Unstaged changes after reset: M CONTRIBUTING.md $ git status On branch master Changes to be committed: (use “git reset HEAD …” to unstage) renamed: README.md -&gt; README Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: CONTRIBUTING.md 这个命令有点儿奇怪，但是起作用了。 CONTRIBUTING.md 文件已经是修改未暂存的状态了。 Note虽然在调用时加上 --hard 选项可以令 git reset 成为一个危险的命令（译注：可能导致工作目录中所有当前进度丢失！），但本例中工作目录内的文件并不会被修改。 不加选项地调用 git reset 并不危险 — 它只会修改暂存区域。 到目前为止这个神奇的调用就是你需要对 git reset 命令了解的全部。我们将会在 重置揭密 中了解 reset 的更多细节以及如何掌握它做一些真正有趣的事。 4.2. 撤消对文件的修改如果你并不想保留对 CONTRIBUTING.md 文件的修改怎么办？ 你该如何方便地撤消修改 - 将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）？ 幸运的是，git status 也告诉了你应该如何做。 在最后一个例子中，未暂存区域是这样： Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: CONTRIBUTING.md 它非常清楚地告诉了你如何撤消之前所做的修改。 让我们来按照提示执行： $ git checkout -- CONTRIBUTING.md $ git status On branch master Changes to be committed: (use “git reset HEAD …” to unstage) renamed: README.md -&gt; README 可以看到那些修改已经被撤消了。 Important你需要知道 git checkout -- [file] 是一个危险的命令，这很重要。 你对那个文件做的任何修改都会消失 - 你只是拷贝了另一个文件来覆盖它。 除非你确实清楚不想要那个文件了，否则不要使用这个命令。 如果你仍然想保留对那个文件做出的修改，但是现在仍然需要撤消，我们将会在 Git 分支 介绍保存进度与分支；这些通常是更好的做法。 记住，在 Git 中任何 已提交的 东西几乎总是可以恢复的。 甚至那些被删除的分支中的提交或使用 --amend 选项覆盖的提交也可以恢复（阅读 数据恢复 了解数据恢复）。 然而，任何你未提交的东西丢失后很可能再也找不到了。 5.远程仓库的使用5.1. 远程仓库的使用为了能在任意 Git 项目上协作，你需要知道如何管理自己的远程仓库。 远程仓库是指托管在因特网或其他网络中的你的项目的版本库。 你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。 与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。 管理远程仓库包括了解如何添加远程仓库、移除无效的远程仓库、管理不同的远程分支并定义它们是否被跟踪等等。 查看远程仓库如果想查看你已经配置的远程仓库服务器，可以运行 git remote 命令。 它会列出你指定的每一个远程服务器的简写。 如果你已经克隆了自己的仓库，那么至少应该能看到 origin - 这是 Git 给你克隆的仓库服务器的默认名字： $ git clone https://github.com/schacon/ticgit Cloning into &apos;ticgit&apos;... remote: Reusing existing pack: 1857, done. remote: Total 1857 (delta 0), reused 0 (delta 0) Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done. Resolving deltas: 100% (772/772), done. Checking connectivity... done. $ cd ticgit $ git remote origin 你也可以指定选项 -v，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。 $ git remote -v origin https://github.com/schacon/ticgit (fetch) origin https://github.com/schacon/ticgit (push) 如果你的远程仓库不止一个，该命令会将它们全部列出。 例如，与几个协作者合作的，拥有多个远程仓库的仓库看起来像下面这样： $ cd grit $ git remote -v bakkdoor https://github.com/bakkdoor/grit (fetch) bakkdoor https://github.com/bakkdoor/grit (push) cho45 https://github.com/cho45/grit (fetch) cho45 https://github.com/cho45/grit (push) defunkt https://github.com/defunkt/grit (fetch) defunkt https://github.com/defunkt/grit (push) koke git://github.com/koke/grit.git (fetch) koke git://github.com/koke/grit.git (push) origin git@github.com:mojombo/grit.git (fetch) origin git@github.com:mojombo/grit.git (push) 这样我们可以轻松拉取其中任何一个用户的贡献。 此外，我们大概还会有某些远程仓库的推送权限，虽然我们目前还不会在此介绍。 注意这些远程仓库使用了不同的协议；我们将会在 在服务器上搭建 Git 中了解关于它们的更多信息。 5.2. 添加远程仓库我在之前的章节中已经提到并展示了如何添加远程仓库的示例，不过这里将告诉你如何明确地做到这一点。 运行 git remote add &lt;shortname&gt; &lt;url&gt; 添加一个新的远程 Git 仓库，同时指定一个你可以轻松引用的简写： $ git remote origin $ git remote add pb https://github.com/paulboone/ticgit $ git remote -v origin https://github.com/schacon/ticgit (fetch) origin https://github.com/schacon/ticgit (push) pb https://github.com/paulboone/ticgit (fetch) pb https://github.com/paulboone/ticgit (push) 现在你可以在命令行中使用字符串 pb 来代替整个 URL。 例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行 git fetch pb： $ git fetch pb remote: Counting objects: 43, done. remote: Compressing objects: 100% (36/36), done. remote: Total 43 (delta 10), reused 31 (delta 5) Unpacking objects: 100% (43/43), done. From https://github.com/paulboone/ticgit * [new branch] master -&gt; pb/master * [new branch] ticgit -&gt; pb/ticgit 现在 Paul 的 master 分支可以在本地通过 pb/master 访问到 - 你可以将它合并到自己的某个分支中，或者如果你想要查看它的话，可以检出一个指向该点的本地分支。 5.3. 从远程仓库中抓取与拉取就如刚才所见，从远程仓库中获得数据，可以执行： $ git fetch [remote-name] 这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。 如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，git fetch origin 会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意 git fetch 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。 如果你有一个分支设置为跟踪一个远程分支，可以使用 git pull 命令来自动的抓取然后合并远程分支到当前分支。 这对你来说可能是一个更简单或更舒服的工作流程；默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或不管是什么名字的默认分支）。 运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。 推送到远程仓库当你想分享你的项目时，必须将其推送到上游。 这个命令很简单：git push [remote-name] [branch-name]。 当你想要将 master 分支推送到 origin 服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字），那么运行这个命令就可以将你所做的备份到服务器： $ git push origin master 只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。 5.4. 查看远程仓库如果想要查看某一个远程仓库的更多信息，可以使用 git remote show [remote-name] 命令。 如果想以一个特定的缩写名运行这个命令，例如 origin，会得到像下面类似的信息： $ git remote show origin * remote origin Fetch URL: https://github.com/schacon/ticgit Push URL: https://github.com/schacon/ticgit HEAD branch: master Remote branches: master tracked dev-branch tracked Local branch configured for &apos;git pull&apos;: master merges with remote master Local ref configured for &apos;git push&apos;: master pushes to master (up to date) 它同样会列出远程仓库的 URL 与跟踪分支的信息。 这些信息非常有用，它告诉你正处于 master 分支，并且如果运行 git pull，就会抓取所有的远程引用，然后将远程 master 分支合并到本地 master 分支。 它也会列出拉取到的所有远程引用。 这是一个经常遇到的简单例子。 如果你是 Git 的重度使用者，那么还可以通过 git remote show 看到更多的信息。 $ git remote show origin * remote origin URL: https://github.com/my-org/complex-project Fetch URL: https://github.com/my-org/complex-project Push URL: https://github.com/my-org/complex-project HEAD branch: master Remote branches: master tracked dev-branch tracked markdown-strip tracked issue-43 new (next fetch will store in remotes/origin) issue-45 new (next fetch will store in remotes/origin) refs/remotes/origin/issue-11 stale (use &apos;git remote prune&apos; to remove) Local branches configured for &apos;git pull&apos;: dev-branch merges with remote dev-branch master merges with remote master Local refs configured for &apos;git push&apos;: dev-branch pushes to dev-branch (up to date) markdown-strip pushes to markdown-strip (up to date) master pushes to master (up to date) 这个命令列出了当你在特定的分支上执行 git push 会自动地推送到哪一个远程分支。 它也同样地列出了哪些远程分支不在你的本地，哪些远程分支已经从服务器上移除了，还有当你执行 git pull 时哪些分支会自动合并。 远程仓库的移除与重命名如果想要重命名引用的名字可以运行 git remote rename 去修改一个远程仓库的简写名。 例如，想要将 pb 重命名为 paul，可以用 git remote rename 这样做： $ git remote rename pb paul $ git remote origin paul 值得注意的是这同样也会修改你的远程分支名字。 那些过去引用 pb/master 的现在会引用 paul/master。 如果因为一些原因想要移除一个远程仓库 - 你已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者某一个贡献者不再贡献了 - 可以使用 git remote rm ： $ git remote rm paul $ git remote origin 6.打标签6.1. 列出标签在 Git 中列出已有的标签是非常简单直观的。 只需要输入 git tag： $ git tag v0.1 v1.3 这个命令以字母顺序列出标签；但是它们出现的顺序并不重要。 你也可以使用特定的模式查找标签。 例如，Git 自身的源代码仓库包含标签的数量超过 500 个。 如果只对 1.8.5 系列感兴趣，可以运行： $ git tag -l &apos;v1.8.5*&apos; v1.8.5 v1.8.5-rc0 v1.8.5-rc1 v1.8.5-rc2 v1.8.5-rc3 v1.8.5.1 v1.8.5.2 v1.8.5.3 v1.8.5.4 v1.8.5.5 6.2. 创建标签Git 使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。 一个轻量标签很像一个不会改变的分支 - 它只是一个特定提交的引用。 然而，附注标签是存储在 Git 数据库中的一个完整对象。 它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。 通常建议创建附注标签，这样你可以拥有以上所有信息；但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。 6.3. 附注标签在 Git 中创建一个附注标签是很简单的。 最简单的方式是当你在运行 tag 命令时指定 -a 选项： $ git tag -a v1.4 -m &apos;my version 1.4&apos; $ git tag v0.1 v1.3 v1.4 -m 选项指定了一条将会存储在标签中的信息。 如果没有为附注标签指定一条信息，Git 会运行编辑器要求你输入信息。 通过使用 git show 命令可以看到标签信息与对应的提交信息： $ git show v1.4 tag v1.4 Tagger: Ben Straub &lt;ben@straub.cc&gt; Date: Sat May 3 20:19:12 2014 -0700 my version 1.4 commit ca82a6dff817ec66f44342007202690a93763949 Author: Scott Chacon &lt;schacon@gee-mail.com&gt; Date: Mon Mar 17 21:52:11 2008 -0700 changed the version number 输出显示了打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息。 6.4. 轻量标签另一种给提交打标签的方式是使用轻量标签。 轻量标签本质上是将提交校验和存储到一个文件中 - 没有保存任何其他信息。 创建轻量标签，不需要使用 -a、-s 或 -m 选项，只需要提供标签名字： $ git tag v1.4-lw $ git tag v0.1 v1.3 v1.4 v1.4-lw v1.5 这时，如果在标签上运行 git show，你不会看到额外的标签信息。 命令只会显示出提交信息： $ git show v1.4-lw commit ca82a6dff817ec66f44342007202690a93763949 Author: Scott Chacon &lt;schacon@gee-mail.com&gt; Date: Mon Mar 17 21:52:11 2008 -0700 changed the version number 6.5. 后期打标签你也可以对过去的提交打标签。 假设提交历史是这样的： $ git log --pretty=oneline 15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch &apos;experiment&apos; a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support 0d52aaab4479697da7686c15f77a3d64d9165190 one more thing 6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch &apos;experiment&apos; 0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function 4682c3261057305bdd616e23b64b0857d832627b added a todo file 166ae0c4d3f420721acbb115cc33848dfcc2121a started write support 9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile 964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo 8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme 现在，假设在 v1.2 时你忘记给项目打标签，也就是在 “updated rakefile” 提交。 你可以在之后补上标签。 要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）: $ git tag -a v1.2 9fceb02 可以看到你已经在那次提交上打上标签了： $ git tag v0.1 v1.2 v1.3 v1.4 v1.4-lw v1.5 $ git show v1.2 tag v1.2 Tagger: Scott Chacon &lt;schacon@gee-mail.com&gt; Date: Mon Feb 9 15:32:16 2009 -0800 version 1.2 commit 9fceb02d0ae598e95dc970b74767f19372d61af8 Author: Magnus Chacon &lt;mchacon@gee-mail.com&gt; Date: Sun Apr 27 20:43:35 2008 -0700 updated rakefile ... 6.6. 共享标签默认情况下，git push 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样 - 你可以运行 git push origin [tagname]。 $ git push origin v1.5 Counting objects: 14, done. Delta compression using up to 8 threads. Compressing objects: 100% (12/12), done. Writing objects: 100% (14/14), 2.05 KiB | 0 bytes/s, done. Total 14 (delta 3), reused 0 (delta 0) To git@github.com:schacon/simplegit.git * [new tag] v1.5 -&gt; v1.5 如果想要一次性推送很多标签，也可以使用带有 --tags 选项的 git push 命令。 这将会把所有不在远程仓库服务器上的标签全部传送到那里。 $ git push origin --tags Counting objects: 1, done. Writing objects: 100% (1/1), 160 bytes | 0 bytes/s, done. Total 1 (delta 0), reused 0 (delta 0) To git@github.com:schacon/simplegit.git * [new tag] v1.4 -&gt; v1.4 * [new tag] v1.4-lw -&gt; v1.4-lw 现在，当其他人从仓库中克隆或拉取，他们也能得到你的那些标签。 检出标签在 Git 中你并不能真的检出一个标签，因为它们并不能像分支一样来回移动。 如果你想要工作目录与仓库中特定的标签版本完全一样，可以使用 git checkout -b [branchname] [tagname] 在特定的标签上创建一个新分支： $ git checkout -b version2 v2.0.0 Switched to a new branch &apos;version2&apos; 当然，如果在这之后又进行了一次提交，version2 分支会因为改动向前移动了，那么 version2 分支就会和 v2.0.0 标签稍微有些不同，这时就应该当心了。 7.Git 别名在我们结束本章 Git 基础之前，正好有一个小技巧可以使你的 Git 体验更简单、容易、熟悉：别名。 我们不会在之后的章节中引用到或假定你使用过它们，但是你大概应该知道如何使用它们。 Git 并不会在你输入部分命令时自动推断出你想要的命令。 如果不想每次都输入完整的 Git 命令，可以通过 git config 文件来轻松地为每一个命令设置一个别名。 这里有一些例子你可以试试： $ git config --global alias.co checkout $ git config –global alias.br branch $ git config –global alias.ci commit$ git config –global alias.st status 这意味着，当要输入 git commit 时，只需要输入 git ci。 随着你继续不断地使用 Git，可能也会经常使用其他命令，所以创建别名时不要犹豫。 在创建你认为应该存在的命令时这个技术会很有用。 例如，为了解决取消暂存文件的易用性问题，可以向 Git 中添加你自己的取消暂存别名： $ git config --global alias.unstage &apos;reset HEAD --&apos; 这会使下面的两个命令等价： $ git unstage fileA $ git reset HEAD – fileA 这样看起来更清楚一些。 通常也会添加一个 last 命令，像这样： $ git config --global alias.last &apos;log -1 HEAD&apos; 这样，可以轻松地看到最后一次提交： $ git last commit 66938dae3329c7aebe598c2246a8e6af90d04646 Author: Josh Goebel &lt;dreamer3@example.com&gt; Date: Tue Aug 26 19:48:51 2008 +0800 test for current head Signed-off-by: Scott Chacon &lt;schacon@example.com&gt; 可以看出，Git 只是简单地将别名替换为对应的命令。 然而，你可能想要执行外部命令，而不是一个 Git 子命令。 如果是那样的话，可以在命令前面加入 ! 符号。 如果你自己要写一些与 Git 仓库协作的工具的话，那会很有用。 我们现在演示将 git visual 定义为 gitk 的别名： $ git config --global alias.visual &apos;!gitk&apos;]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
